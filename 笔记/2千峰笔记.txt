   
    文字语言< 在计算机语言中用 &lt;    表示
    文字语言> 在计算机语言中用 &gt;    表示
    文字语言& 在计算机语言中用 &amp;   表示

   label-attribute-value 
    标签-属性-值
    <table>
       < td align：left> <td>
    <table>

    <a href="jiavascript:;">服装</a>       //可以让超链接无法点开


    <p>段落</p>  
   9. 标题与段落？
    标题 ➡ 双标签 ：    <h1></h1>。。。<h6></h6>
    在网页中最重要 在一个网页中 h1只能出现一次
    h5 h6标签在网页中不经常使用
    段落： 双标签：     <p></p>
   
    <blockquote>标签和<q>标签都表示“引用”
区别：
    一、格式不同
        1、<q>：</q>标签是行内元素，在内容的开始和结尾处会包有【“ ”】；
        2、<blockquote>：blockquote是块级元素，默认带有内左右40px的外间距，不带【“ ”】。
    二、语义不同
        1、<q>：引用的是小段文字；
        2、<blockquote>：引用的是大段容的内容块。

   10. 文本修饰 ？
    强调 ➡ 双标签：   <strong></strong>  <em></em>  
    <strong>加粗</strong>  
     <em>加斜线</em>  
     区别 :
            1.strong的强调性更强 em的强调性稍弱
              strong会加粗       em文本加斜  
            
    下标：  <sub></sub>  
    下标：  <sup></sup>
    删除文本 ： del
    添加文本 ： ins
    一般删除文本和添加文本一块使用

    <i>标签
    <i> 定义与文本中其余部分不同的部分，并把这部分文本呈现为斜体文本。
    <i> 标签被用来表示科技术语、其他语种的成语俗语、想法、宇宙飞船的名字等等。
    在没有其他适当语义的元素可以使用时，请使用 <i> 元素。其他语义的元素如下：

    <em> （被强调的文本）
    <strong> （重要的文本）
    <mark> （被标记的/高亮显示的文本）
    <cite> （作品的标题）
    <dfn> （一个定义项目）

    11. 图片标签
    <img>
        src : 引入图片的地址
        alt : 当图片出现问题的时候，可以显示一段友好的文字提示
        title :  当鼠标点击图片的时候，显示提示信息
        width：  设置宽
        right：  设置高
        不加宽高的时候，若网速慢，图片上下的段落会闭合在图片加载出来后慢慢撑开
        加宽高后，会在图片还未加载出来的时候根据宽高，段落已经固定，把图片位置空出来

        引入文件的地址路径
            相对路径：
            .在路径中表示当前路径
            ..在路径中表示上级路径
            绝对路径：
            F:/VS/练习文件/vc code/imgs/缩小猫 (6).jpg   <!-- 电脑中的一个具体位置 -->
            http://image.baidu.com/search/              <!-- 一个网络地址 -->

    13. 链接标签

    a   ➡ 双标签 <a> </a> 
        href   :链接的地址
        target ：（目标）可以改变链接打开的方式   
        默认值为：    target："_self" 在原来窗口打开链接
        新窗口打开：  target："_blank"在新的窗口打开链接  
    <!--blank表示新窗口 black表示黑色  block表示块  display:none表示隐藏-->

    base➡  单标签 <base target："">
        作用就是改变链接的默认行为
        
    14. 跳转锚点：
        1. neme
         <a href="#middle">回到中间</a>
         <a name="middle"></a>
         <p>中间</p>
         设置一个name锚点，不在里面设置内容，这样就不占网页空间，
         造成在下一行显示锚点的假象

        2. id
        <a href="#top" >回到最顶端</a>
        <p id="top">最顶端</p>
        设置ID 跳转到ID相对应的锚点位置

    15.特殊字符
        1. &+字符
        2. 解决冲突啊 左右尖括号 添加多个空格的实现
        3. &lt; &gt; &nbsp;

    16.列表标签

        1. 无序列表➡ ul li  两个必须配套使用 ul和li之间不能有其他标签
        <ul>
        <li>
        </li>
        </ul>

        type属性：改变前面标记的样式（一般都是用CSS去控制）

        2.有序列表➡ ol li  两个必须配套使用 ol和li之间不能有其他标签
        注：有序列表用的非常少，经常使用无序列表，无序列表可以去代替有序列表

        想要去掉前面的小圆点：
        小圆点消失后还会占据原来位置显示空白，   ul {list-style=none}  或者 li {list-style: none;}  
        小圆点消失也不占据空白                 ul {padding: 0;}
        不过一般会写全面一点                   ul,li{padding:0; margin:0; list-style:none;}
       


        3.定义列表
        <dl>: 定义列表
            <dt>：定义专业术语或名词
            <dd>：对名词进行解释和描述
        <dl>: 定义列表

        注：列表之间可以互相嵌套，形成多层级的列表
        


    17.表格标签
        <table>: 表格的最外层容器
        <caption>：定义表格标题
        <tr>: 定义表格第几行
        <th>：定义表头      一般表示 第一行的第几列
        <td>：定义表格单元 第几列
       
        注：之间是有嵌套关系的，要符合嵌套规范
        
        语义化标签：
        <tHead>  <tBody>  <tFood>
        注释：在一个table中，tBody可以有多个，但是tHead和tFood只有一个

        表格属性
        [注]：在表格中cellspacing,rules，border这些是HTML属性，不属于CSS语法，所以只能写在HTML标签上 
        border:表格边框宽度
        cellpadding：单元格内与文字之间的间距
        cellspacing：单元格之间的空间
        align：左右对齐方式    值：left center right
        valign：上下对齐方式   值：top middle bottom
        rowspan： 合并的行数  竖着合并
        colspan： 合并的列数  横着合并

       
        
fu
18 表单标签

    表单能够包含input 元素，比如文本字段、复选框、单选框、提交按钮等等。
    表单还可以包含 menus、textarea、fieldset、legend 和 label 元素。表单用于向服务器传输数据。
    表单必需的 action：属性规定当提交表单时，向何处发送表单数据。

        form                     表单标签 
        textarea                 多行文本框标签
        select option            下拉菜单标签
        label                    辅助表单标签label元素的for与checkbox和radio的ID相同 组成一组 增大点击范围
        input：                  标签有一个属性type属性，决定是什么控件。
            input type=
            输入  类型=       
            input typee=text         账号   
            input type=password      密码
            input type=checkbox      复选框
            input type=radio         单选框
            input type=file          上传文件  <input type="file" multiple> 批量上传
            input type=submit        提交
            input type=reset         重制
        
    还有一些常见的属性：
    只要写在行内就生效true/false用在dom操作
    checked、                   disabled                         selected           focus()       blur()          
    单选\多选标签默认选择        禁止一个单选\多选\下拉标签          下拉默认选择        获取光标       失去
    true生效\false失效          true禁止效果生效\false禁止失效      true生效\false失效      
    <textarea name="" id="" cols="30" rows="10"  style="resize: none;"></textarea > resize控制多行文本框是否可以拉伸大小

    <input type="button" checked> 表示禁用 btnNode.disabled = false;表示可以用     

    <input type="radio" id="male"> 
    <label for="male">男</label>        增加点击范围

    <select name:'' id:''>      
        <option value:'xxx'>男 </option>     
        <option>女 </option>
    </select>
    
        select name 属性规定 select 元素的名称。用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据。
        option value 之间的值是浏览器显示在下拉列表中的内容，而 value 属性中的值是表单被提交时被发送到服务器的值。如果没有指定 value 属性，选项的值将设置为 <option> 标签中的内容。

    <input type="text" placeholder="请输入账号">placeholder 属性提供可描述输入字段预期值的提示信息，
    该提示会在输入字段为空时显示，并会在字段获得焦点时消失。
     注释：如何让表单标签居中给标签添加div  margin："auto" 外面div padding:设置数值

19. div和span
    div:做一个区域划分的块
    span:

20 css

21.css样式的引入方式？
    1.内联样式      style属性
   
    2.内部样式      style标签  

    3.外部样式      link标签     
                     
    {   link：联系 链接
        line：线 边界 排列方式}
    
    引入一个单独的css文件 name.css 
    通过<link>标签引入外部资源
    rel     属性指定资源跟页面的关系  
    href    属性指定资源的地址
   
    @import url()     <!--夹在style标签当中-->
    import 引入会有许多问题 所以不建议使用
22.css中颜色表示法
    1.单词表示法
    2.16进制标识法
    3.RGB三原色表示法 
    rgb（255，255，255） 取值范围0~255

    css背景样式
   1 background-color:
   2 background-image：
   3 background-repeat：  背景图片的平铺方式
        background-repeat:repeat-x
        background-repeat:repeat-y
        background=repeat:repeat                     
        background-repeat:no-repeat                                                              
    
   4 background-position： 背景图片的位置
     background-posstion：x y : mumber | 单词
                          x ；left center right
                          y : top center tottom


   5 background-attachment 背景图片随滚动条的移动方式 
     background-attachment:scroll (背景位置是按照当前元素进行偏移的)
     background-attachment:fixed （背景位置是按照当前浏览器进行偏移的,可以形成视觉差效果）
     
23. CSS边框样式？
    border-style : 边框样式     
            solid  : 实线       border-style-solid  
            dashed : 虚线       border-style-dashed
            dotted : 点状边框。在大多数浏览器中呈现为实线。
    border-width : 边框大小  
            top             /* 通过border-top-width设置上边框的粗细*/  
            bottom 
            left
            right
    border-color : 边框颜色        
            rde #f00 ...
    编辑也可以针对某一边框进行单独设置： border-left-style：中间是方向 left bottom right top
            transparent 透明颜色 

24.css文字样式
    font-family ：字体类型    
    font-weight ：字体粗细    right（右边）weight(重量) height（高度）width（宽度）
    font-size ：  字体大小
    font-style  : 字体样式   
    color  ：字体颜色 
   
    1.font-family ：字体类型 
        英文字体 Arial， Times New Roman, 
        中文字体 宋体（SimSun） ， 微软雅黑('Microsoft Yahei')
        衬线体与非衬线体
        注意点:
            1.多个字体类型的设置目的  /*设置多个字体是防止计算机之别不了备用*/
            2.引号的添加目的  /*是字体中间有空格的话需要有引号包裹起来*/
    2.font-size ：字体大小
            默认 ：16px
            写法 数值number（px）
            
            单词写法：不推荐使用
            xx-small                最小
            x-small                 较小
            small                   小
            medium                  正常（16px）即不设置默认 就是这个大小
            large                   大
            x-large                 较大
            XX-large                最大
    3.font-weight ：字体粗细
            模式： 正常{normal}  加粗 {bold}  只有两种
            写法： 单词(normal、bold)  
            number（100 200 ，，， px）最大900，从100到500都是正常的 600到900是加粗
    4.font-style  : 字体样式
            模式 ： 正常{normal}  斜体{ italic}   
            写法 :  单词{normal、italic}
            注 ：oblique也表示斜体，但是用的比较少，一边了解就可以
           
            区别：
                1.italic 只有带有倾斜属性字体的才可以设置
                2.oblique 没有带有倾斜属性的字体也可以设置倾斜操作 
    5. color 字体颜色 

25. css段落样式
    text-decoration:
        下划线 underline
        删除线 line-through
        上划线 overline
        不添加任何修饰 none

    text-transform:  英语单词大小写
        小写 lowercase
        大写 uppercase
        只针对首字母大小写 capitlize
        js中 node.toLowercase() == "需要判断大小写的内容" 来判断是否是全小写

    text-indent:  文本首行缩进  字体默认是16px 所以默认设置32px
         em ：  
         如果font-size字体大小有变化，需要text-indent设置为字体大小两倍才能首行缩进，
         很不方便，这是后可以设置2em ,及2倍em，em默认跟随字体大小变化缩进两个字体。但是
         如果里面有英文，就有可能对不齐，因为英文字体大小和汉字大小不同。

    text-align  文本左右对齐方式
        left  所对齐
        right 右对齐
        center 中间对齐
        justify 左右两端点对齐 
         
    line-height  定义文本行高 

        什么是行高，一行文字的高度，上边距和下边距的等价关系 
        默认行高不是固定值，二十变化的，根据当前字体大小在不断的变化   

        取值：1 number(px)  | scale (比例值，跟文字大小)

    letter-spacing 字之间的间距

    word-spacing  词之间的间距  （只针对英文段落的)

    英文和数字不自动折行的问题：
    1. word-break:break-all (非常强烈的折行)
    2. word-wrap: break-word (不是那么强烈的折行,会产生一些空白) 

26.css复合样式 

    复合的写法，是通过空格的方式实现的,复合写法有些是不需要关心顺序的例如 ：
    1 boacground :red url（） repeat 0 0；
    2 border: 1px red solid;
    有的是需要关心顺序的例如font.
    font : 
        注：最少要有两个值 size family （写在最后面保持顺序一致）
        weight style size family
        style weight size  family
        weight style size/line-height family

     注 ：尽量不要复合与单一写法混用，如果非要混合去写的话，
         一定要先写复合样式，再写单一样式

27.css选择器
    1. id选择器
        #elem { }   id=“elem”
    注 ：
    1. ID是唯一值，在一个页面中也只能出现一次，多次出现是不复合规范的。
    2. 命名的规范：由字母、下划线、中划线、字母（并且第一个不能是数字）
    3. 驼峰式写法： searchButton(小驼峰) SearchButton(大驼峰)
       短线写法  ： search-small-button
       下划线写法： search_small_button
    
    2. class选择器
        .elem { }   class="elem"
    注：
    1. class选择器是可以复用的。
    2. 可以添加多个class样式。
    3. 多个样式的时候，样式的优先级是根据CSS决定的，而不是根据class属性中的顺序。
    4. 标签+类的写法。

    3.标签选择器(tar 选择器)
        div { }      <div> </div>

    4.群组选择器()分组选择器
        可以通过逗号的方式，给多个不同的选择器，添加统一的CSS样式，来达到代码的复用。
         div,p,span {}    

    5.通用选择器（通配选择器）
        * { } 
        注：尽量避免使用，因为会给所有的表填添加样式
        使用场景：
            1.去掉所有标签的默认样式时
    
    6.层次选择器

        后代 M N    { }   后面的所有后代元素
        父子 M>N    { }   父元素为M的后面一代子元素
        兄弟 M~N    { }   当前M下的所有兄弟N标签  
        相邻 M+N    { }   当前M相邻的一个N标签

    7.属性选择器
        M[class]   { }     所有带class属性全部选择
        M[class=]  { }     所有完全匹配的选择
        M[class*=] { }     部分匹配
        M[class^=] { }     起始匹配
        M[class$=] { }     结束匹配
        M[class][id] { }   组合选择器 选择即含有class属性又含有id属性的标签
    
    8.伪类选择器

        M:伪类[]   例如 link visited hover active
        :like               访问前的样式        （只能添加给a标签）
        :visited            访问后的样式        （只能添加给a标签）
        :hover              
        移入前的样式     （可以添加给所有标签）   
        :active             鼠标按下时的样式     （可以添加给所有标签）  
        :after              给div后面添加一段text
        :before             给div前面添加一段text

        注：如果想让四个伪类选择器都生效 一定要注意顺序：L V H A
            一般网站都只设置a{linke、visiited、active}    a:hover{}

        :after、:before     通过伪类的方式给元素添加一些文本内容,使用irtent属性    
        例如：
        div:after{content:text} 给div后面添加一段text, 
        div:before{content:text}给div前面添加一段text，
        好处就是例如给一段文本添加颜色 div:after{content:这段文字添加颜色；color:red}  
                                    <div>这段文字不加颜色</div> 而不使用span标签
        :checked、 :disabled、 :focus、 都是针对表单元素的
        :checked    选择 当默认选中时的标签
        :disabled   选择 当默认不能选中时的标签
        :focus      ：伪类在元素获得焦点（即光标出现）时向元素添加特殊的样式。例如 HTML 中一个有文本输入焦点的输入框，
        其中出现了文本输入光标；也就是说，在用户开始键入时，文本会输入到这个输入框。
        其他元素（如超链接）也可以有焦点，不过 CSS 没有定义哪些元素可以有焦点。
        
    结构性伪类选择器：
        :nth-of-type()   :nth-child（）
        角标是从1开始的，1表示第一项，2表示第二项 
        或者
        n值，n表示从0到无穷大的所有值 2n表示偶数 n+1表示奇数   

        :nth-of-type()  type类型    类似兄弟节点   例如li:nth-of-type(2)  li集合里第二个选中 
            的区别
        :nth-child（）  child孩子   类似父子节点   例如li:nth-child(2)    li父节点ul下的第二个节点如果式li才会有效过

例子
    <div>
        <p>第一行</p>
        <p>第二行</p>
        <p>第三行</p> 
        <span>我是测试行</span>
    </div> 

        xx:last-child     判断父元素的最后一个是不是xx,是的话生效
            选择父节点最后一个子节点，并且与选择器进行匹配，父节点div的最后一个节点是span，
            而匹配的选择器是p,两者不对应所以匹配不上。 

        xx:last-of-type   xx集合里找到最后一个元素
            是从父节点的子节点中寻找最后一个与选择器相同的子节点，也就是说，
            这次寻找的并不是最后一个节点，而是最后一个P元素节点，所以只能找到第三行了。       
例子：
    <ul>                        <ul>               
        <p>1</p>                     <p>1</p>
        <p>2</p>                     <p>2</p>
        <p>3</p>                     <p>3</p>
        <li>1</li>                   <li>1</li>
        <li>2</li>                   <li>2</li>
        <li>3</li>                   <li>3</li>
    </ul>                       </ul>

    li:nth-of-type(2)       li集合中第二个会生效  两个Ul都有效果 

    不加限制条件的话任何父元素下的li都会生效,如果加了ul>li限制条件的话,只有ul下的li生效,div等其他标签下的li不生效

    li:nth-child(4)         li的父元素ul下的第四个是li才会生效




        first-of-type   第一个
        last-of-type    最后一个
        only-of-type    仅有的一个的时候，当集合大于等于2时，没有效果

    扩展：
        伪类选择器 (不修改dom内容，通过一些特定的选择器根据特定的状态，特定条件来修改元素的样式。)
        伪元素和伪类选择器不是一个东西
        伪元素： (css3规定伪元素由两个冒号开头作为标示::,可能会改变dom结构，创建虚拟dom。)
    　　    ::before,::after //这两个伪类会在选择的元素的前面和后面创建虚拟dom 通常和content联合shiyong
    　　    ::first-letter,first-line //这两个伪类只要用于改变选中元素内文本节点的第一个字母，第一行的样式
    　　    ::selection //用于修改用户用鼠标选中的文本的样式，仅限于color、background、cursor、outline的修改。
            IE9+、Opera、Google Chrome 以及 Safari 中支持 ::selection 选择器。Firefox 支持替代的 ::-moz-selection

28.css继承
    文字相关的样式可以继承
    布局的相关样式不能继承 （默认是不能继承的，但是可以设置inherit值来继承）

29.css优先级
    1.相同样式优先级
        当设置相同样式时，后面的优先级较高，但不建议出现重复设置样式的情况。
    2.内部样式与外部样式
        内部样式与外部样式优先级相同，如果都设置了相同的样式，那么后写的引入方式优先级高。
    3.单一样式优先级
    style行间> ID > class > tag（标签） > * > 继承

        注 : shtyle行间     权重        1000
             ID                        10
             class                     1
    
    4. !important
        提升样式优先级，非规范方式，不建议使用。(不能针对继承的属性进行优先级的提升)
    
    5.标签+类 >单类   优先级

    6. 群组优先级
    群组选择器与单一选择器在同一个级别，优先级相同，靠后的优先级高。

    7.层次优先级
        1.权重比较
            ul li .box p input {}    1+1+10+1+1
            .hello span #elem {}     10+1+100
        
        2.约分比较
            ul li .box p input {}      li p input {}
            .hello span #elem {}       #elem {}  
    
30.css盒子模型?

    组成 : content ➡ padding ➡ border ➡ margin
            物品        填充物     包装盒    盒子与盒子之间的间距 

            content : 内容区域width和height组成

            padding ： 内边距 （内填充）[相对于boder到content内容之间的填充效果]
                只写一个值：    30px （上下左右）
                写两个值        30px 40px （上下、左右）
                写四个值        30px 40px 50px 60px （上、右、下、左）
                padding-left
                padding-right
                padding-top
                padding-bottom

            margin ： 外边距（外填充） [相对于border与外部其他标签之间的距离]
                margin-left
                margin-right
                margin-top
                margin-bottom
            注：
                1.背景色填充到margin以内的区域（不包括Margin区域）
                2.文字在content的区域添加
                3.padding不能为负数，而Margin可以为负数

    box-sizing
        盒尺寸：可以改变盒子模型的展示形态。
        默认值: content-box : width、height作用到content区域
        作用值：border-box ：  width、height作用到content padding border ，   
        例如使用box-sizing：border-box;使padding形成向内填充，
          默认值box-sizing：content-box;使padding形成向外填充，
     

        使用场景：
            1.不用再去计算一些值
            2.解决一些百分比的问题

    盒子模型的一些问题：
        1.Margin叠加问题，出现在上下Margin同时存在的时候.会取上下之中较大的值作用出来 
        解决方案：1.BFC规范     2.想办法只给一个元素添加边距 
        2.Margin传递问题，出现在嵌套的结构中，只时针对margin-top的问题。
        解决方案：1.BFC规范     2.给父容器加边框    3.Margin换成padding
  
    扩展：
        1.Margin左右自适应是可以的，但是上下自适应是不行的。
        即：{margin-left:auto;  margin-right:auto;}
        会使标签左右居中
        2.width、height不设置的时候，对盒子模型的影响:会自动去计算容器的大小，节省代码
        3.利用margin与position使 容器居中
        position: absolute; left: 50%; top: 50%; margin：-1/2的height 0 0 -1/2的width

31.标签分类？
    块级元素、行内(内联)元素和行内块元素

块状元素：
　　块状元素代表性的就是<div>，其他如<p>、<nav>、<aside>、<header>、<footer>、<center>、
    <section>、<article>、<ui>、<li>、<ol>、<address>、<h1>~<h6>、<form>、<dir>、<hr>、<pre>、
    <table>、<dl>、<menu>等等，都可以用div来实现。不过为了可以方便程序员解读代码，一般都会使用特定的语义化标签，
    使得代码可读性强，且便于查错。
块状元素特征：
　　(1)能够识别宽高
　　(2)margin和padding的上下左右均对其有效
　　(3)可以自动换行
　　(4)多个块状元素标签写在一起，默认排列方式为从上至下

 

行内元素：
　　行内元素最常使用的就是<span>，其他如<a>、<abbr>、<acronym>、<b>、<big>、<br>、
    <cite>、<code>、<dfn>、<em>、<font>、<i>、<img>、<input>、<label>、<kbd>、<q>、
    <s>、<samp>、<select>、<small>、<strike>、<sub>、<sup>、<strong>等等。
行内元素特征：
　　(1)设置宽高无效
　　(2)对margin仅设置左右有效，上下无效；padding设置上下左右都有效，即会撑大空间
　　(3)不会自动进行换行


行内块状元素
　　行内块状元素综合了行内元素和块状元素的特性，但是各有取舍。
    因此行内块状元素在日常的使用中，由于其特性，使用的次数也比较多，
    如<button>、<del>、<iframe>、<ins>、<map>、<object>等等。
行内块状元素特征：
　　(1)不自动换行
　　(2)能够识别宽高
　　(3)默认排列方式为从左到右


块级元素和行内元素相互转换：
　　　　display:inline; //转换成行内元素
　　　　display:block; //将行内元素转换成块级元素
　　　　display:inline-block; //转换为行内块状元素


替换元素和非替换元素

替换元素：指浏览器是根据元素的属性来判断具体要显示的内容的元素。比如 <img> 标签，
    浏览器是根据其 src 的属性值来读取这个元素所包含的内容的，
    其他替换元素有：<input> 、<textarea>、 <select>、 <object>、<iframe> 和 <video> 等等，
    这些元素都有一个共同的特点，就是浏览器并不直接显示其内容，而是通过其某个属性的值来显示具体的内容，
    比如浏览器会根据 <input> 中的 type> 的属性值来判断到底应该显示单选按钮还是多选按钮亦或是文本输入框。

非替换元素：比如 <p> 、<labe>  元素等等，浏览器直接显示元素所包含的内容。
部分元素设置margin-top和margin-bottom, padding-top和padding-bottom不能起作用也是因为
替换元素可替换内容的关系而已导致, 当中：

    替换元素: 是指用作为其他内容占位符的一个元素。如： <img>、input> 等起作用;

    非替换元素:是指内容包含在文档中的元素 如：<span>等不起作用；



        注：布局一般用块元素，修饰一般用行内元素
    按类型
        block : div、p、ul、li、hi···
            1.独占一行
            2.支持所有样式
            3.不写宽的时候跟父元素的宽度相同
            4.所占区域是一个矩形

        inline : span、a、em、strong、img···
            1.挨在一起
            2.有些样式不支持，例如：width、height、margin-top -bottom、padding-top
            img除外。
            3.不写宽的时候，宽度由内容决定撑开多少
            4.所占区域不是一个矩形
            5.内联标签之间会有空隙，原因：换行产生的

        inline-block : input、 select···  
            1.挨在一起，支持宽高      

    按内容分类
        Flow：流内容
        Meatdata: 元数据
        Sectioning: 分区
        Heading： 标题
        Phrasing：措辞
        Embedded: 嵌入的
        Interactive: 互动的
    
    按显示分类
        非替换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容
        例如：<input type=" ">   <img src=" " alt=" ">
              
        非替换元素：直接将内容告诉浏览器，将其显示出来
        例如： h1 div p···

32.显示框类型
    display:
        block
        inline
        inline-block
        none                    让指定的标签不在页面上进行任何显示
    注意： 
        display:none             不占空间的隐藏(后面的元素会浮动上来)
        区别
        visility:hidden         占空间的隐藏

    
visibility: hidden和display: none 在作用、对把HTML元素的影响、定义上有所不同:

        1、作用不同
        display: none           将元素的显示设为无，即在网页中不占任何的位置。
        visibility: hidden      将元素隐藏，但是在网页中该占的位置还是占着。

        2、使用后HTML元素有所不同
        display:none，          使用该属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”。
        visibility:hidden，     使用该属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），
                                而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。

        3、定义不同
        visibility              属性指定一个元素是否是可见的。
        display                 这个属性用于定义建立布局时元素生成的显示框类型。

33.标签嵌套规范？

    ui、li
    dl、dt、dd
    table、tr、td

    块标签可以嵌套内联标签
        例如：
        <div>
            <span></span>
            <a href="#"> </a>
       </div>
    块标签不一定能嵌套块标签
        特殊情况 错误写法：
            <p>
                <div></div>
            </p>
    内联标签不能嵌套块标签
        例如：
        <span>
             <div></div>
        </span>
        特殊情况 正确写法：
        <a href="#"> 
            <div></div>
        </a>

33.溢出隐藏
    overflow:
        visible         默认不隐藏
        hidden          隐藏      
        scroll          下拉滚动条,不管内容多不多都有滚动条
        auto            当内容多的时候有滚动条,不多时没有

    x轴 y轴:
    overflow-x:
    overflow-y:

34.透明度与手势?

    opacity : 0(透明) ~ 1(不透明)           0.5(半透明)

        注:占空间,所有的子内容也会透明

    rgba() : 0 ~ 1  例如:rgba (255,0,0,  0.5)
            
        注:可以让指定的样式透明,而不影响其他样式

    cursor : 手势
        default :   默认箭头
        help    :   箭头加问号
        pointer :   手型
ico
        要实现自定义手势: 要准备图片 (.cur  或者  .ico)

35.最大、最小宽高

    min-width、min-height
    max-width、max-height

    %单位：换算→以父容器的大小进行换算

    一个容器怎么适应屏幕的高：
        html,body {height：100%}
        容器 {height:100%}

36.css默认样式
    没有默认样式的：div span
    有默认样式的：

        body    ➡  margin:8px
        h1      ➡  margin:上下 21.440px
                    font-weight : bold
        p       ➡  margin:上下 16px
        ul      ➡  margin:上下 16px    padding:左 40px
                    默认的点： list-style : disc
        a       ➡  text-decoration:underline    <!-- 下划线 -->


    css reset:
        * {margin:0; padding:0;}
            优点：不用考虑那些标签有默认的Margin和padding
            缺点：稍微影响性能
            body,p,h1,ul {margin:0; padding:0;}

        ul {list-style:none;}  
            去掉前面圆点
        
        a {text-decoration:none; color:   }

        img { display:block}
            问题的现象:图片和容器底部有一些空隙
            原因：内联元素的对齐方式是按照文字的基线对齐的，而不是文字的底线对齐的。
                    img {vertical-align:baseline}   默认值

            解决    img {vertical-align: bottom;}   和最底部对齐
                    img { display: block;}          把img变成一个块元素
                    img{vertical-align:middle}      垂直居中
        写具体页面的时候或写一个布局效果的时候：
            1.写结构
            2.css重制样式
            3.写具体样式

37.float 浮动?
    文档流:        文档流是文档中可显示对象在排列时所占用的位置
    float特性:     脱离文档流,沿着父容器靠左或靠右排列.如果之前已经有浮动的元素, 会挨着浮动的元素进行排列
    取值:          left right none(默认)
    float注意点:   只会影响后面的元素,对于浮动之前的元素不造成任何影响
                   内容默认提升半层
                   默认宽度跟据内容决定
                   排列换行:在父元素内前一行放不下会换行排列                                                                                                                                                                      
                   主要给块元素添加,但也可以为内联元素添加
                   浮动不会继承给子元素

    如何清除浮动>
        上下排列:   clear属性,表示清除浮动, left right both(左右都可以清除)
        (clear属性只会操作块标签,对内联标配前不起作用)

        嵌套排列:   
            固定宽高        : 不推荐,不能把宽高固定死,不适合左自适应的效果.
            父元素浮动      : 不推荐,因为父元素浮动也会影响到后面的元素.
            overflow:hidden(BFC规范),如果有子元素想溢出,那么会受到影响.
            display:inline-block(BFC规范):不推荐,父元素会影响到后面的元素.
            设置空标签      :不推荐,会多增加一个标签.
            after伪类       : 推荐,是空标签的加强版,目前各大公司的做法.
            即在受到浮动影响布局的标签，需要清除浮动的标签上面添加一个空标签，再给空标签添加伪类
            无论是clear:both 还是 :after {content: ''; display: block; clear: both;}
            都是谁受到影响，谁来添加，可以理解为这不是清除浮动，而是清除受到浮动的影响

    overflow:hidden 特性的使用总结:

        1. overflow:hidden  清除浮动
        一般而言，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动float之后，
子元素会脱离标准流，不占位，父级元素检测不到子元素的高度,父级元素高度为0。那么问题来了,由于父级元素没有高度,下面的元素会
顶上去,造成页面的塌陷。因此，需要给父级加个overflow:hidden属性，这样父级的高度就随子级容器及子级内容的高度而自适应。
        2.  overflow:hidden  溢出隐藏
        给一个元素中设置overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。

        3.overflow:hidden  解决外边距塌陷
        即子元素margin-top传递问题,如果给子元素添加margin-top会传递给父元素也产生margin-top效果,所以添加overflow:hidden
后,父元素不会产生外边距效果而是增大自身的高度来满足子元素所需要margin-top效果


38.position定位?
    css position属性用于指定一个元素在文档中的定位方式.top right bottom left属性决定了该元素的最终位置.
                取值
    position：  static          (默认)
                relative        相对定位
                absolute        绝对定位
                fixed           固定定位
                sticky          粘性定位
                

    relative相对定位特性:
        如果没有相对偏移量,对元素本身没有任何影响
        不使元素脱离文档流
        不影响其他元素布局
        left top right bottom是相对于当前元素本身进行偏移的  
        (反向偏移 position:relative; left:100px 相对于左边原来位置偏移（远离左边100px）,
        即向右偏移100个像素) 
        
        
       注：祖先元素：只要是包裹着该元素的父元素都是其祖先元素,就是父元素是祖先元素,爸爸的爸爸也是祖先元素

    absolute绝对定位特性:
        使元素脱离文档流
        使内联元素支持宽高(让内联元素具备块的特性)
        使块元素默认宽根据内容决定(让块具备内联的特性)
        如果有定位祖先元素,则根据相对于的,(绝对 相对 固定)定位祖先元素发生偏移,
        如果没有定位祖先元素,则对于整个文档发生偏移（body）
        (反向偏移 position:absolute; left:100px 相对于左边原来位置偏移,即向右偏移100个像素) 

    fixed固定定位特性:
        使元素完全脱离文档流
        使内联元素支持宽高(让内联元素具备块的特性)
        使块元素默认宽根据内容决定(让块具备内联的特性)
        相对于整个浏览器窗口进行偏移,不受浏览器滚动条的影响     
        在有滚动条的情况下，把元素固定在窗口一个位置，即使页面滚动，依旧在窗口的固定位置显示

    sticky粘性定位特性:
        在指定的位置,进行粘性操作,不随窗口的移动而移动，类似于Excel中的冻结窗口效果
        在有滚动条的情况下，移动到一定距离后不再移动，固定在原地

    z-index定位层级
        默认层级为0  
        若两个div:
         Z-index:0;
         z-index:1;  则1的div层级在上面(类似于浮动)

        嵌套时候的层级问题

添加省略号的四个步骤
    width                   必须要有一个固定的宽
       
    white-space:nowrap      不让内容折行
        
    overflow:hidden         隐藏溢出内容
        
    text-overflow:ellipsis  添加省略号

39.CSS sprite
    特性:
        css雪碧也叫做CSS精灵图,是一种网页图片应用的处理凡是.他允许你将一个网页
涉及到的所有零星图片都包含都一张大图中去加载.
    好处:
        可以减少图片的质量,网页的图片加载速度快.
        减少图片的请求次数,加快网页的打开.  

40.css圆角
    border-radius:
        给标签添加圆角  左 右 右下 左下

41.pc端页面布局
    通栏:自适应浏览器的宽度             container-fluid     
    
    版心:固定一个宽度,并让容器居中      container

        

第二章
1. html 与 XHTML区别

    DOVTYPE文档即编码
    元素大小写                      html5不区分
    属性布尔值
    属性引号                        html5属性值可以不加引号  text-align:center;
    图片的alt属性                   html5 可以不写alt属性 
    单标签的写法                    html5单标签结束不用写/
    双标签闭合                      html5可以不写结束的后边标签 
                 
2.strong和b、em和i?

    strong和em都是表示强调的标签,
    区别strong和em都具有语义化,而b和i不具备语义化

3.引用标签

    blockquote      ：      引用大段的段落解释
    q               ：      引用小段的短语解释
    abbr            ：      缩写或首字母缩略词
    address         ：      引用文档地址信息
    cite            ：      引用著作的标题

4.iframe标签？

    可以引入其他的html到当前的html中显示

    frameborder             规定是否显示框架周围的边框（0 或者 1）
    width                   定义iframe的宽度
    height                  定义iframe的高度
    scrolling               规定是否在iframe中显示滚动条
    src                     规定在iframe中引入的url
    srcdoc                  固定在iframe中显示的页面内容

    应用场景：数据传输、共享代码、局部刷新、第三方介入等。

5.br 与 wbr？
    br：换行，              Wbr：软换行

    提示：如果单词太长，或者担心浏览器会在错误的位置换行，那么可以使用Wbr元素来添加
Word Break Opportunity(单词换行时机)


6.pre与code？ 针对网页中的程序代码使用的

    pre元素 可以定义预格式化的文本，被包围在Pre元素中的文本通常会保 留空格 和 换行符
    code元素 只应该在表示计算机程序源代码或者其他机器可以阅读的文本内容上使用code标签。
    虽然code标签通常只是把文本变成宽体字，但它暗示着这段文本时源程序代码。

7.map 与 area?

    给特殊图形添加链接。area能添加的热区的形状：矩形、圆形、多边形。
    例：
        <img src="" alt="" usemap="#id">
        <map name="id">
            <area shape="" coords="" href="" alt="">        <!-- rect矩形 circ圆 poly多边形-->
        <map>

8. embed 与 object？

    embed和object都表示能够嵌入一些多媒体，如flash动画、插件等。基本没有什么太多的区别，
主要时为了兼容不同的浏览器。

9. audio 与 video?          引入音频与视频的标签，属于H5的新功能

    audio标签表示嵌入音频文件，video标签表示嵌入视频文件。默认控件是不显示的，
可以通过controls属性来显示控件。(没有controls 不会显示)
    autoplay    自动播放
    loop        循环播放           

    为了支持多个备选文件的兼容性，可以配合source标签使用。

10.文字注解？ 与文字反写
ruby、rt 这样一个组合

    <ruby>
        文字 <rt>拼音</rt>    
    </ruby>

<bdo dir="rtl">需要反写的文字</bdo> 
或者
css 样式加{direction: rtl; unicode-bidi: bidi-override;}

11.link扩展学习？

    （1）添加网址标题栏前的小图标：
        <link rel="shortcut icon " type="/images/x-icon" href="/favicon.ico"> 
<!-- 图片不一定必须ico格式 -->
<!-- 将href换成图片位置即可 --> 
备注：这里的favicon必须是16*16或者32*32的，必须是8位色或者24位色的，格式必须是png或者ico或者gif。
16*16/32*32 且 8位或24位色 且 png/ico/gif。

    （2）引入一个单独的css文件
        <link rel="stylesheet" type="text/css" href="">

    （3）DNS解析
    <link rel="dns-prefetch" href="">

12.meta扩展学习？

    meta添加一些辅助学习.

    <meta name="description" content="描述，例如：大连美团惊险大连美食、餐厅、酒店预订、等信息。下载美团官方APP,吃喝玩乐1折优惠。">

    <meta http-equiv="refresh" content="0; url=0秒后跳转的地址">

13.HTML5新语义化标签
    header、fonter、min在一个网页之中只能出现一次

    header              :   页眉
    footer              :   页脚   
    main                :   主题
    hgroup              :   标题组合   
    nav                 :   导航                一般坐标
    article             :   独立的内容          一般中间部分
    aside               :   辅助信息的内容      一般是右边侧边栏
    section             :   区域
    figure              :   描述图像或者视频    一般组合来用    
    figcaption          :   描述图像或者视频的标题部分  一般组合来用
    datalist            :   选项列表
    details / summary   :   文档细节 / 文档标题
    progress/ meter     :   定义进度条 /定义度量范围
    time                :   定义日期或时间
    mark                :   带有标号的文本

14.表格的扩展学习
    添加单线             :            border-collapse:collapse
    
    隐藏空单元           :            empty-cells:hide  （内容为空白的标签，不显示边框）
  
    斜线分类             :            border    /   rotate
  
    列分组               :            colgroup  /   col （直接按顺序针对某一列进行操作）

15.表单的扩展学习
    
    扩展标签
        fieldset        :           表单内元素分组
        legend          :           为fieldset元素定义标签
        optgroup        :           定义选项框
    
    
    美化表单控件：        1.   label ：checked   2.position : opacity

    1：
    label input {display: none;}
    label input:checked + div {background-position:px px;}
    label div {width:; height:; background: url() px px;}

    2：
    div父 {width: 266px; height: 75px; position: relative;}
    div {width: 100%; height:100%;background: url() ;}
    div父 input {width: 100%; height:100%;left:0; top: 0; position: absolute;opacity: 0;}

    <div>                           width:; height:; position: relative;
        <input type="file">         width: 100%; height:100%;background: url();
        <div></div>                 width: 100%; height:100%; position: absolute;left:0;top:0;opacity:0;
    </div>

    新的input控件
        email                   :           电子邮箱输入框
        url                     :           网址输入框
        number                  :           数值输入框
        range                   :           滑动条
        date/ month /week       :           日期控件
        search                  :           搜索框
        color                   :           颜色控件
        tel                     :           电话号码输入框（在移动端会默认调起数字键盘）
        time                    :           时间控件

    新的表单属性：
        autocomplete            :           自动完成    默认值NO打开  OFF关闭
        autofocus               :           获取焦点
        required                :           不能为空
        pattern                 :           正则验证    显示输入类型 例如 数字 字母

        method                  :           数据传输方式
        enctype                 :           数据传输类型
        nome / value            :           数据的键值对


16.BFC规范？
    触发
    BFC规范的元素 ，可以形成一个独立的容器，不受外界的影响，从而解决一些布局的问题

    触发BFC条件：
        float：     除 none 以外的值  
        position：  (absolute、 fixed)
        display：   inline-block、 table-cells、 flex
        overflow：  除了visible以外的值 hidden、auto、scroll(加滚动条)
    
    可以解决的问题：
        margin的传递问题
        margin的叠加问题        不能用inline-block
        解决浮动的问题
        解决覆盖的问题         用position


第三章 css3
1  浏览器前缀?
    CSS3去兼容不同的浏览时，针对旧的浏览器做兼容，新浏览器基本不需要加前缀


2.transition 过度?

    合并书写顺序 transition：property duration delay timing-function

    transition-property         :  规定设置过度效果的CSS属性的名字   (默认值为all)                   
    transition-duration         :  规定完成过度效果需要多少秒或者毫秒
    transition-delay            :  定义过度效果何时开始(延迟为正数，提前数值为负数)
    transition-timing-function  :  规定速度效果的速度曲线         (默认值为ease、平均值为linear)
                                    ease       动画以低速开始，然后加快，在结束前变慢。
                                    ease-in    动画以低速结束。   
                                    ease-in-out动画                                             
                                    cubic-bezier(n,n,n,n)在cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。   
                                    linear  平均值匀速

    transition控制的是CSS的属性,需要变换的属性 变换需要的时间 控制动画速度变化 延期多少时间后开始执行 

                    transition:width 2s;

                    transition:translate 2s;

                    transtion:all 2s;



3.transform 变形？  是给元素本身进行变形 不控制属性

    transform:translate(xp xp)      偏移位置
              translateX
              translatey
              translateZ （3D效果）

    transform:scale                 缩放（值为一个比例值，正常大小就是1,会以当前元素中心点放大）
              scaleX
              scaleY
              scaleZ（3D效果）

    transform:rotate                旋转 (旋转的值，单位是角度deg.正值为顺时针旋转   弧度rad)
              rotateX（3D效果）
              rotateY（3D效果）
              rotateZ

    transform:skew                  斜切 （单位是角度，正值向左倾斜，负值向右倾斜）
              skewX
              skewY

    transform-origin                变形基点  
                x轴正值为右 负值为左
                y轴正值为下 负值为上

    trabsform的注意事项：
        1. 变形操作不会影响其他元素
        2. 变形操作是能添加给块元素，但是不能添加给内联元素。
        3. 复合写法，可以添加多个变形操作。
            执行是有顺序的，先执行后面的操作，再执行前面的操作。
            translate会受到 rotate scale skew 影响


4.animation 动画?    

    合并书写顺序 animation: name duration timing-function delay iteration-count direction;

    animation-nome:                 设置动画的名字
    animation-duration：            动画的持续时间
    animation-timing-function：     动画的运动形式
    animation-delay：               动画的延迟时间
    anmation-itration-count：       动画的重复次数，默认值就是1，infinite无限次数
    animation-fill-mode:            固定动画播放之前或之后，其动画效果是否可见
                                    none(默认值)：在运动结束之后回到初始的位置，在延迟的效果下，让0%在延迟后生效     
                                    backwards:   在延迟的情况下，让0%在延迟前生效
                                    forwards:    在运动结束之后，停在结束位置
                                    both:        backwards和forwards同时生效 
    
    animation-direction :           属性定义是否该轮流反向播动画
        alternate：                  一次正向（0%~100%),一次反向（100%~0%)
        reverse：                    永远都是反向，从100%~0%
        normal（默认值）：            永远都是正向，从0%~100%                       

    animation-play-state:paused;      停止动画
    animation-play-state:running;     停止动画
    

    注：
        1.运动结束后，默认情况下，会停留都在起始的位置
        2.@keyframes ➡ 0%    ， to ➡ 100%

        动画和变形结合使用
            在元素本身的身上加animation:name time...;动画效果
            在元素下面另写变形@keyframes name{
                form{transform:   }
                to{transform:     }
            }
    例如：
        @keyframes name{
            from{transition: rotate(0);}
            to{transition: roatte(360deg);}
        }

5. animate.css 动画库
        库文件下载地址：https://github.com/animate-css/animate.css
        动画效果名称选择地址 https://animate.style/
        
        引入方法
        <head>
            <link rel="stylesheet" href="../animate.css">
        </head>
        <body>
            <div   class="animate__animated   animate__动画效果名称 ">
        </body>

6. 3D操作？     
    transform:
        rotateX（）         正值向上翻转        在XY轴中正值都会向第一相限旋转  在屏幕绕z轴转
        rotateY（）         正值向右翻转        在XY轴中正值都会向第一相限旋转
        translateZ（）      正值向前，负值向后
        scaleZ（）          立体元素的厚度

    3D写法
        scale3d() :         三个值 x y z
        translate3d():      三个值 x y z
        rotate3d():         四个值0|1（x轴是否添加旋转角度）      
                                0|1（y轴是否添加旋转角度）        
                                0|1（Z轴是否添加旋转角度）        
                                deg
                              

                                


3D相关的属性
    perspective(景深):      离屏幕多远的距离去观察元素，值越大幅度越小。
    perspective-origin:     景深——基点位置，观察元素的角度。

    transform-style:        3D空间
        flat                (默认值2D)  
        preserve-3d         (3d，产生一个三维空间)

    transform-origin:       变形——基点 X Y Z (center center -50px  Z轴只能写数值，不能写单词) 
    backface-visibility：   背面隐藏    visible（默认值、可视的）、hidden
        
    
7.CSS3提供的扩展背景样式
    background-size： px                    背景图的尺寸大小
                cover                       覆盖
                contain                     包含

    background-origin:                      背景图的填充位置
                padding-box（默认）
                boreder-box
                content-box
    background-clip:                        背景图的裁切方式
                padding-box
                boreder-box（默认）
                content-box

    注：复合样式的时候，第一个是位置，第二个是裁切。
d
8.CSS3渐变?
    1.线性渐变 ➡ linear-gradient是值，需要添加到background-image属性上
    background-image:linear-gradient  背景颜色渐变

    注：
    （1）默认值是从上往下渐变
    （2）如果使用deg 渐变的0度是在页面的下面往上的位置，然后正值会按顺时针旋转，负值按逆时针旋转

    2.径向渐变 ➡ radial-gradient  以半径为范围渐变圆形

9.CSS3字体图标 font-face
    好处：
        1.非常方便的改变大小和颜色
        2.放大后不会失真
        3.减少请求次数和提高加载速度
        4.简化页面布局
        5.减少设计师和前端工程师的工作量
        6.可使用计算机没有提供的字体
    
    使用@font-face
        像woff、mac、linux等文件都是做兼容平台处理的， 
        阿里巴巴矢量图标库官网：  https://www.iconfont.cn/
        自定义字体图标       ：  https://icomoon.io/app/#/select
       
10.CSS3文字的阴影
    text-shadow 
    x   y   blur   color
    轴 轴   模糊值  颜色
    注：阴影的颜色默认和文字颜色相同
    注：通过逗号的隔开设置多阴影
    
11.css3盒子阴影
    box-shadow:
    x轴  y轴   blur        spread     color   inset   ,多阴影的话多写几个样式用逗号隔开
              模糊度    阴影的大小范围  颜色    内阴影

    注: x值为正向右偏移 y值为正向下偏移     
    注：盒子阴影默认颜色是黑色
    注: 默认就是外阴影，如果设置outset不起作用，可选的值只有inset表示内阴影


12.css3 mask 遮罩
    url
    repeat
    x
    y
    w
    y
    多遮罩

13.css3倒影
    box-reflect
        above   上
        below   下
        left
        right
        距离
        遮罩 | 渐变


14.css3模糊与四则计算
      blur
	filter : blur()

      calc
	四则计算    例：width:calc(100% - 100px)

15.分栏布局
    column-count : 分栏的个数
      
    column-width : 分栏的宽度
      
    column-gap : 分栏的间距
      
    column-rule : 分栏的边线
      
    column-span : 合并分栏

注：分栏column-count 和 clumn-width 不要同时设置

16.伪类与伪元素
    在CSS2.1中对伪类和伪元素的区别比较模糊。CSS3中对这两个概念做了相对较清晰地解释，
    并且在语法上也做了很明显的区分。
    伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息。通常表示获取不存在与DOM树中的信息，
    或获取不能被常规CSS选择器获取的信息。

        : hover

        : focus

        : empty

    CSS3中规定伪类由一个冒号开始，然后为伪类的名称；伪元素由两个冒泡开始，然后为伪元素的名称。
    伪元素本质上是创建了一个有内容的虚拟容器。这个容器不包含任何DOM元素，但是可以包含内容。
    另外，开发者还可以为伪元素定制样式。

        :: selection    (选中的)

        :: first-line   /    first-letter

        :: before     /     after 
        …	

17.css  Hack分类
   
	1. CSS属性前缀法 （IE6及以下_  IE6-7 +或*  IE6-9 \9  IE8-11 \0
	2. 选择器前缀法   (IE6*html    ie7*+html  IE9及以上高级浏览器:root )
	3. IE条件注释法

    注：CSS Hack用来解决浏览器的兼容性问题，为不同版本的浏览器定制编写不同的CSS效果，使用每个浏览器单独识别的样式代码，
    控制浏览器的显示样式。
        ie10已经不支持ie条件注释法
        属性前缀法是在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果。
        选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack
        ie条件注释法这种方式是IE浏览器专有的Hack方式，微软官方推荐使用的hack方式。


18.ie低版本bug
        由于旧浏览器在设计上有很多缺陷，导致一些BUG的产生，所以针对这些问题需要做出兼容处理。

        常见兼容问题
        1. 透明度
        2. 双边距
        3. 最小高度
        4. 图片边框
        .....

19.渐进增强与优雅降级
    渐进增强：针对低版本浏览器进行构建网页，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进
和追求功能达到更好的用户体验。
    优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容

20.页面布局
    等高布局 ：利用 margin-bottom负值与padding-bottom正值，相等合计为0 
    例：margin-bottom: -2000px; padding-bottom: 2000px;

    三列布局，左右固定，中间自适应：
        1.bfc方式  
        2.定位      左右定位 中间margin居中
        3.浮动      (双飞翼布局（利用margin-left负值）、圣杯布局) 
        4.flex弹性

第四章 
    Flex弹性盒模型 :
        随着移动互联网的发展，对于网页布局来说要求越来越高，而传统的布局方案对于实现特殊布局非常不方便，比如垂直居中。
        2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。
        目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。
1.作用在flex父容器上的属性：
    flex-direction:         （左、右开始排列方向）用来控制子项整体布局的方向，是从左往右还是从右往左。是从上往下还是从下往上。
            row             默认值，显示为行。方向为当前文档水平流方向，默认情况下是从左往右。
            row-reverse     显示为行，但（文字content）方向和row属性值是反的    (和float:right效果相似 但是不改变文字方向)
            column          显示为列,从上往下排列
            column-reverse  显示为列，但是方向和colmun属性值是反

    flex-wrap:              (换行)用来控制子项单行显示还是换行显示
            nowrap          默认值，表示单行显示，不换行,会尽量压缩子元素大小来进行适配，直到压缩不了，才会溢出
            wrap            宽度不足换行显示
            wrap-reverse    宽度不足换行显示，但是和wrap反方向

    flex-Flow：     属性是flex-direction和flex-wrap的缩写，表示flex布局的flow流动特性。第一个只表示方向，第二个值表示换行，中间用空格隔开。


    justify-content:        (主轴分布方式)  属性决定了主轴方向上子项的对齐和分布方式。 
            flex-start      默认值，表现为起始位置对齐。
            flex-end        表现为结束位置对齐
            center          变现为居中对齐
            space-between   变现为两端对齐。between是中间的意思，意思是多余的空白间距只在元素中间区域显示。
            spaec-around    around是环绕的意思，意思是每个flex子项两侧都环绕互不相干扰的等宽的空白间距，最终视觉上边缘两次的空白只有中间空白宽度的一办
            space-evenly    evenly表示均匀、平等的意思，也就是在视觉上，每个flex子项两侧空白间距完全相等。
           
           
    align-items:           (侧轴对齐方式)items指的就是flex子项们，因此align-items指的就是flex子项们，相对于flex容器在侧轴方向上的对齐方式。       
            stretch         默认值，flex子项拉伸铺满
            flex-start      变现为容器顶部对齐
            flex-end        表现为容器底部对齐
            center          表现为垂直居中对齐
    表现形式为用于一行子项的对齐方式,因为只有多行才会有分布，一行只是对齐方式
    
    aling-content:          (侧轴分布方式）可以看成是justify-content是相似却对立的属性，如果所有flex子项只有一行，则aligin-content属性是没有任何效果的。
            stretch         默认值，每一行flex子元素都等比例拉伸。例如：如果共两行flex子元素，则每一行拉伸高度都是50%。
            flex-start      表现为起始位置对齐
            flex-end        表现为结束位置对齐
            center          表现为居中对齐
            space-between   表现为两端对齐
            space-around    每一行元素上下都享有独立不重叠的空白空间
            apace-evenly    每一行元素上下等分
    表现形式为用于多行子项的对齐、分布方式，因为只有多行才会有分布，一行只是对齐方式

        
2.作用在flex子元素（子项）上的CSS属性：
    order                   可以通过设置order改变flex子项的排序位置，所有flex子项的默认order属性值为0

    flex-grow               属性中grow是扩展的意思，扩展的就是flex子项所占据的宽度的百分比，
                            扩展所侵占的空间就是除去元素外的剩余的空白间隙。默认值为0 （设置的都是比例值）
                            1为占据剩余所有空间

    flex-shrink             属性中shrink是“收缩"的意思们。flex-shrink主要处理当flex容器空间不足的时候，
                            单个元素的收缩比例。默认值为1正常收缩。
                            0表示不收缩 大于1表示更加收缩（设置的都是比例值）
 
    flex-basis              定义了在分配剩余空间之前元素的默认大小,重新设置

    flex                    flex属性是flex-grow、flex-shrink、flex-basis的缩写
                            但是与单独写 flex-grow=0 效果不一样，因为优先级问题 flex-grow=0的时候，width只对flex-grow生效，不对flex复合写法生效

    align-self              指控制单独某一个flex子项的侧轴对齐方式。
                            和父容器中的align-items作用像是，只不过
                            align-items：所有子集
                            align-self:  单个子集
                

Grid网格布局
    Grid布局是一个二维的布局方法，丛横两个方向总是同时存在

    1.作用在Grid容器上 写在父元素上     
        grid-template-columns（行）   
        grid-template-rows   （列）   
            对网格进行横纵划分，形成二维布局。单位可以是像素，百分比，自适应以及fr单位（网格剩余空间比例单位）
            有时候，我们网格的划分很有规律的，如果需要添加多个横纵网格时，可以利用repeat()语法进行简化操作
           
        grid-template-arese
            area是区域的意思，grid-template-areas就是给我们的网格划分区域的。
            此时grid子项只要使用grid-area属性指定其隶属于那个区。
            根据矩阵划分子项区域
            grid-template-areas: ( 相互配合使用 写在父容器上)
            "a1 a1 a1"
            "a2 a2 a3"      
            "a2 a2 a3";
            grid-area：a1 （相互配合使用 写在子项上）     


        grid-template
        grid-template是grid-template-rows，grid-template-columns和grid-template-areas属性的缩写。
        从易读易写的角度考虑，还是建议不要合并属性.
       
        grid-column-gap
        grid-row-gap
            属性用来定义网格中网格间隙的尺寸。

         grid-gap
            CSS grid-gap属性是grid-row-gap 和 grid-column-gap属性的缩写。


    针对网格内元素
        justify-items（横）  指定了网格内 的元素的水平呈现方式，是水平拉伸，还是左中右对齐。 （元素大小根据内容自动撑开）
        align-items（纵）    指定了网格内 的元素的垂直呈现方式，是处置拉伸，还是上中下对齐。 （元素大小根据内容自动撑开）
            :stretch        默认值，拉伸。表现为水平或垂直居中       （元素大小根据内容自动撑开）
            :start          表现为容器左侧或者顶部对齐              （元素大小根据内容自动撑开）
            :end            表现为容器右边或者底部对齐              （元素大小根据内容自动撑开）
            :center         表现为水平或者垂直居中对齐              （元素大小根据内容自动撑开）
         place-items        place-items可以让align-items和justify-items属性写在单个声明中。(先纵后横向)
   
    针对网格
        justfy-content      指定了网格的水平分布方式
        align-content       指定了网格的垂直分布方式
            :stretch        默认值，拉伸。表现为水平或者垂直居中
            :start          表现为容器左侧或者顶部对齐方式
            :end            表现为容器右侧或者顶部对齐方式
            :center         表现为水平或者垂直居中对齐
            :space-between  表现为两端对齐
            :space-around   享有独立不重叠的空白空间
            :space-evenly   平均分配空白空间
        place-content

    2.作用在Grid子项上,写在子向上
        grid-column-start   列线（即水平方向上占据的）起始位置
        grid-column-end     列线（即水平方向上占据的）结束位置    
        grid-row-start      行线（即垂直方向上占据的）起始位置
        grid-row-end        行线（即垂直方向上占据的）结束束位置
        grid-column         grid-column-start 和 grid-column-end的简写 
        grid-row            grid-row-start 和 grid-row-end的简写

        注：
        span属性表示从开始位置截取空间个数
        例如：grid-row-end:span 2;已设置的grid-column-end，从起始到结束位置方向截取2个单位 
        例如：grid-row-start:span 2;已设置的grid-column-start，从结束到起始位置方向截取2给单位

        
        grid-area       是 grid-row 和 grid-column 的简写
                        第一个值为水平row的起始位置 / 第二个值为垂直column的起始位置 /
                        第三个值为水平row的结束位置 / 第四个值为垂直column的结束位置 


        justify-self        单个网格内元素的水平对齐方式
        align-self          单个网络元素的垂直对齐方式
        place-self          align-self 和 justify-self的缩写     (先纵后横向)             









        总结
        flex :   
            写在父元素上 作用在子项
            justify-content     横轴  分布效果 单行多行都有效果 
            align-content       纵轴  分布效果 单行多行都有效果 
            align-items         纵轴  与父容器边的对齐位置
            flex-direction      横纵  横纵轴在父容器边的对齐位置与文档流起始方向
                注释：                                                  
                1。 justify-content：flex-start flex-end 若分布不密集
                    与float:left、 float:right效果相似  
                    与flex-direction：row 、row-reverse效果相似 文档流起始方向不相似
                2。 flex-direction 若分布不密集
                    与align-items与父容器边的对齐位置效果相似、但是文档路起始方向不相似

        网格 :
            1。写在父元素上 作用在子项
            justify-items      在网格大小布局完毕后里面元素对齐方式 横轴  
            align-items        在网格大小布局完毕后里面元素对齐方式 纵轴 
                注释： 注意不是
                例： grid-template-columns: repeat(3 ,100px); 
                一旦设置start end center数值 默认大小，将不是全面拉伸而是自适应，但是会在已经
                布局完部的网格内按start end center值对齐
                与在元素内设置text-align：lefg、right、center效果相似

            2.写在父元素上 作用在子项
            justify-content     网格本身的 分布方式 横轴  
            align-content       网格本身的 分布方式 纵轴 
                注释:如果两个值都是fr，而没有px网格将会占满剩余空间
                    那么两个值所设置的分布方式将变得没有任何的意义

            3.写在子项上 作用在子项上
            justify-self        单个 网格里面的元素 横轴水平 对齐方向 
            align-self          单个 网格里面的元素 纵轴垂直 对齐方向 

            4.  grid-areas
            （1）.box1 div {grid-area: 2 / 3 / 4 / 5  ; background: red;} 表示子项所占起始结束位置
            写在子项上 作用在子项上

            （2）. grid-template-areas: ( 相互配合使用 写在父容器上)
                    "a1 a1 a1"
                    "a2 a2 a3"      
                    "a2 a2 a3";
                    grid-area：a1 （相互配合使用 写在子项上）     


1.移动端模拟器?
    切换平台之后，一定要刷新浏览器

2.去访问一些网站的PC端和移动端
    大一点的网站代码都是分开的，PC一套代码，移动端一套代码

    访问淘宝网 ➡ 后端检测当前设备 ➡ 如果是PC端 ➡ wwwtaobao.com

    访问淘宝网 ➡ 后端检测当前设备 ➡ 如果是移动端 ➡ wwwtaobao.com ➡ 重定向 ➡ h5.m.taobao.com


    在移动端viewport视口就是浏览器显示页面内容的屏幕区域。
    在viewport中有两种视口，分别表示为：
    visual viewport（可视视口） 固定大小跟屏幕大小相同，在上面
    layout viewport（布局视口） 可改变大小，在下面，默认大小为980像素，
    可通过document.documentElement.clientWidth获取。
    
注：
    现代网页需要将layout viewport设置成跟visual viewport等同大小，方便进行网页制作。

viewport设置

    通过<meta>标签进行设置，name属性指定viewport值，content属性进行视口配置
    
    取值                                            含义
    width                       设置layout viewport的宽度特定值，device-width表示设备宽度
    height                      设置layout viewport的高度特定值，一般不进行设置
    initial-scale               设置页面的初始缩放
    minimun-scale               设置页面的最小缩放
    maximun-scale               设置页面的最大缩放
    user-scalable               设置页面能否进行缩放

3.移动端适配方案 

    （1）. 百分比布局，也叫流式布局。代表网站：优酷、百度、天猫、腾讯。
        文字流式（fluid） 控件弹性（flexble） 图片等比缩放（scale）
        好处：大屏幕下显示更多内容  坏处：宽屏下比例会有一些不协调

    （2）. 等比缩放布局，也叫rem布局。代表网站：网易、爱奇艺、淘宝、美团。
        单位：
            em ：       是一个相对单位，1em等于于当前元素或者父元素的font-sezi值。
            rem :       是一个相对单位，1rem等于跟元素的font-size。(根元素就是html这个标签)
              / vh：   把屏幕分成100份，1vw等于屏幕宽的1%,1vh等于屏幕高度的1%。
                       

        动态设置font-size：

            通过JS  js 在var fontsize = document.documentElement.clientWidth / 3.75;
                    document.documentElement.style.fontSize = fontsize + 'px';
                    情况下 1rem = 100px

            通过VW  css 在<html> font-size=26.66666667vw 情况下 1rem = 100px

        注：要给body重制一下font-size：16px  或者16px的等比rem

        因为如果设置给HTML设置font很大的情况下换算为rem的值往往
        很大这是为了给 layout viewport（布局视口）设置大小，转换屏幕大小
        但是会影响到body下的字体大小，所以重制font-size：16px，因为HTML 和 body 的优先级问题使文字正常大小

    (3)响应式布局
        利用媒体进行查询，即media queries，可以针对不同的媒体类型定义不同的样式，从而实现响应式布局。

        媒体类型值。
            all                     适用于所有设备。
            print                   用于打印机和打印预览。
            screen                  用于电脑屏幕，平板电脑，智能手机等。
            speech                  应用于屏幕阅读器等发声设备。    
        
        常见选项
            and 、 not
            min-width 、 max-width
            orientation:portrait、 orientation:landscape   竖屏、 横屏
            <link> 

        例如 @media all and (min-width: 600px) {#box {background: blue;} }
        即 min = > 600为蓝色            或者理解为<600为原来的条件

             @media all and (max-width: 600px) {#box {background: blue;} }
        即 max = < 600为蓝色

        常见修改样式
            display
            float
            width
        注：相应式代码写到要适配的CSS后面。  

Bootstrap
    Bootstrap是最受欢迎的HTML、CSS和JS框架，用于开发响应式布局、移动设备有限的WEB项目

    特色：
        1.响应式布局
        2.基于flex的栅格布局
        3.丰富的组件和工具方式
        4.常剑的交互使用

    官网 http://getbootstrap.com/

    引入bootstrap.css后还可以自行创建组件（类似与代码提示）来方便操作，在VS code扩展中搜索安装：
    [Bootstrap 4, Font awesome 4, Font Awesome 5 Free & Pro snippets组件]
    使用方式： b4-xxx(name) 选择创建需要的组件
    
    Containers容器包含
        container       (width: 100%;margin:0 auto 0 auto; padding：0 15px 0 15px;)
        container-fluid
        responsive breakpoints（响应断点）

    布局细节： 一共12栅格
                                特小        小          中          大          特大
                               <576px     ≥576px     ≥768px      ≥992px      ≥1200px
        最大容器宽度            无（自动）  540px      720px        960px       1140px
        类前缀                  .col-    .col-sm-   .col-md-    .col-lg-     .col-xl-


        列数(# of columns)                            12
        间距(Gutter width)                     30像素（每列15像素）
        可嵌套(Nestable)                              
        列顺序{Column ordering}

1.class细节例如：
        class="row"                         行
        class="col"                         列
        class="w-100"                       折行
        class="col-sm"                      每列平时平均分配，不满足响应式sm条件的话就会垂直
        class="col-4"                       因为一行只有12栅格，所以本列占4/12栅格
        class="col-auto"                    每列根据内容自适应占领
        class="col-md-auto"                 平时自适应，不满足响应式md条件的话就会垂直
        class="row no-gutters"              每行去掉了margin、padding
        class="row align-items-start"       每行 垂直 方向上的对齐方式 start center  end
        class="row justify-content-end"     每行 水平 方向上的对齐方式 start center  end 
        class="col align-self-end"          每列 垂直 方向上的对齐方式 start center  end
        class="col-md-4 offset-md-4"        每列 水平 （在md响应式下占领四个栅格） 偏移4个栅格
        class="col-md-4 ml-auto"            ml-auto : margin-right : auto 
                mt-5                        margin-top : 5rem 
                mt-md-5                     margin-top : 5rem; 在md响应式范围内添加
                mx-5                        margin-left:5rem;  margin-right:5rem;
                my-5                        margin-top :5rem;  margin-bottom:5rem;
                mt-n5                       margin-top : -5rem
                py-5                        padding-top:5rem;  padding-bottom:5rem;

        content
        reboot                              重新启动，单个文件中特定于元素的CSS更改的集合，使用kickstart Bootstrap提供一个优雅，一致且简单的基准。
        typography                          排版Bootstrap排版的文档和示例，包括全局设置，标题，正文，列表等。
        code                                码使用Bootstrap显示内联和多行代码块的文档和示例。
        images
        tables
        figures

        content细节例如：
            class="text-center"             text-align:"center";
            class="carousel-inner"          ::after {content: ""; display: block; clear: both;}
            class="float-lg-left"           在lg响应式下添加一个左浮动
            class="float-md-left"           在md响应式下添加一个左浮动


        img细节：
            class="rounded mx-auto d-block"  圆角  margin-x轴auto display:block   
            class="img-thumbnail"            图片产生一个环绕的外边框

            <figure class="figure">
                <img src="..." class="figure-img img-fluid rounded" alt="...">
                <figcaption class="figure-caption">图形标题样式</figcaption>
            </figure>

2.components(组件)细节：  
    Alerts(警告框)          class="alert alert-xxx" 分别控制：警告的基础类（调出已经设置好宽高大小） 警告框背景-固定的8个颜色
    Badge（徽章）           <button type="button" class="btn btn-primary"> span class="badge badge-light">4</span>
    Breadcrumb（面包屑导航） <nav aria-label="breadcrumb"> <ol class="breadcrumb"> <li class="breadcrumb-item">
    Buttons（按钮）          class="btn btn-xxx"
    Button group（按钮组）
    Card（卡片）
    ...

3.Utilities（工具类 方法）
    borders（边框）                     class="border border-primary"控制有限的颜色 class="border border-top-0"控制减少那条边
    Clearfix（清除浮动）                class="clearfix" 原理是::after {content: ""; display: block; clear: both;}
    Close icon
    Colors（颜色）                      class="text-white-50"  50表示透明度
    Display
    Embed(内嵌))


第五章：
   Sass、Less、 slylus
        Sass和Less都属于CSS预处理器，CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，
    为CSS增加了一些编程的特性，如：变量、语句、函数、继承等概念。即将CSS作为目标生成文件，然后开发者就只
    要使用这种语言进行CSS的编码工作。
    
    less：官网 http://lesscss.org/            vscode插件  Easy LESS

     
    sass：官网 https://sass-lang.com/         vscode插件 Easy Sass

    XX.sass文件   xx.scss文件     都是Sass文件     
        语法：
            注释
            变量\插值\作用域
            选择器嵌套\伪类嵌套\属性嵌套(Sass)
            运算\单位\转义\颜色
            函数
            混入\命名空间(Less)\继承
            合并\媒体查询
            条件\循环
            导入


    PostCSS
        PostCSS本身是一个比较单一的工具。它提供了一种方式用JaveScript代码来处理CSS。
    利用PostCSS可以实现一些工程化的操作，如：自动添加浏览器前缀，代码合并，代码压缩等。
    
    官网： https://postcss.org/
    安装：
            1.  安装node环境
            2.  npm install postcss-cli-g
            3.  -o -w
            4.  postcss.config.css


css架构
    在一个大型项目中，由于页面过多，导致CSS代码难以维护和开发。所以CSS架构可以帮助我们解决文件管理与文件划分的问题。
首先要对CSS进行模块化处理，一个模块负责一类的操作。可利用Sass或者less来实现。

    文件加                                  含义
    base                                一些初始的通用CSS，如重制默认样式，动画，工具，打印等等
    components                          用于构建页面的所有组件，如按钮、表格、表单、弹窗、等
    layout                              用于布局页面的不同部分，如页眉，页脚，弹性布局，网格布局等
    pages                               放置页面之间的不同样式，如首页特殊样式，列表页特殊样式等
    themes                              应用不同的主题样式时，如管理员，卖家，买家等
    abstracts                           放置一些如：变量、函数，响应式等辅助开发的部分
    vendors                             放置一些第三方独立的css文件，如bootstrap、iconfont等

1.css新特性之 自定义属性
    css自定义属性（CSS变量），在目前所有的现代浏览器中得到了支持。
        定义与使用
        计算
        默认值
        作用域

2.css新特性之 shapes
    css shapes布局可以实现不规则的文字环绕效果，需要配合浮动使用.

    shape-outside:  none; margin-box; border-box; padding-box; content-box; polygon(多边形) {文字环绕类型}
    clip-path       polygon( 0 0, 0 100px ,100px 100px) 把图像切割成多边形
    shape-margin    给图像和文字之间产生间距

3.css新特性之 scrollbar
    scrollbar用于实现自动逸滚动条的样式
        ::-webkit-scrollbar                 控制 滚动条宽度 
        ::-webkit-scrollbar-thumb           控制 拇指按的按钮
        ::-webkit-scrollbar-track           控制 轨道颜色 阴影

4.css新特性之 Scroll Snap
    scroll snap（css滚动捕捉）允许你在用户完成滚动后，锁定特定的元素或停留的位置
        scroll-snap-type：x mandatory;          X轴强制吸附    
        scroll-snap-align: end;                 滚动后对齐位置
          


程序被CPU执行
        【注】程序磁盘读取到内存中，被CPU执行。

        关键信息：内存是有空间的，程序本质上是在内存中运行的。
        【注】编程就是合理的分配内存

        了解计算机的组成：磁盘    内存    CPU/GPU

第六章 javascript
    官方概念：这是一个跨平台的脚本语言
    平台➡  windows         跨平台：就是在各种环境下，都可以运行。 脚本语言的特点：不能独立运行，依赖于网页运行
            linux          
            unix
            android
            ios

    web.archive.org  网页时光机 记录了很多明星网站多年前的样子。

    vscode 插件VS ：
    Code JavaScript(ES6) snippets：这个插件为JavaScript、TypeScript、HTML、React和Vue提供了ES6的语法支持。    
    ESLint：最流行的代码检测插件，它的规则在.eslintrc.json里配置。



    历史： ECMA工会

    javascript组成部分：
        1.ECMAScript 3 4 5 6 7      负责JS的语法
        2.DOM                       全称（document object model） 文档对象模型 （操作语法）
        3.BOM 浏览器打开的每一个窗口  全称（browser object model）  浏览器对象逆序（操作浏览器）
    
            
    所有的JS代码都在script标签中编写
            属性：
                1.<script type='text/javascript'></script>  声明当前标签的文本格式（省略）
                2.<script src="./demo.js"></script>         src = 'demo.js' 引入外部.js文件

            注意点:
            1.可以右多个script标签，多个script标签是自上而下顺序执行
            2.一个script标签只能专心做一个事情，不能在标签里面加另一个script

js的输出方法：
        document.write()        在当前页面上输出内容    注:如果内容中含有标签的话会自动解析
        console.log()           在控制台中输入内容      注:一般情况下用于代码测试
        console.time/timeEnd    在控制台输出time到timeEnd之间内容运算的时间
        alert:()                警告框
            关键字：
                typeof
                格式：typeof 常量/变量切换
                功能：输出当前常量或者变量的数据类型
            例子：
                alert(typeof 100);              //输出number 数据类型
                alert(typeof 'hello');          //输出string 数据类型
                alert(typeof true);             //Boolean    数据类型
                alert(typeof undefined);        //undefined  数据类型

        注：   // JS中除数可以为0
                    alert(10 / 0);          Infinity   无穷大
                    alert(-10 / 0);         -Infinity   无穷小

    注意：
        <> 转义字符 &（叫做and符号）：   &lt; &gt;

        单行注释   //                   ctrt + /    快捷键

        多行注释  /*  */                ctrl + shift + / 快捷键 （我的是+a）

        在写JS代码的时候，要在每一行Js代码结尾一定加;（分号）

        代码压缩：去掉编写代码的时候，有的所有空格、tab键和换行。


栈(stack)和堆（heap）的概念

　　stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放


JavaScript 数据类型：
    
    值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。

    复合/引用数据类型：对象(Object)、数组(Array)、函数(Function)。

    解释：
        一、从概念方面来说

        基本数据类型:变量名指向具体的数值
        引用数据类型:变量名指向存数据对象的内存地址,即变量名指向hash值

        二、从内存构建方面来说

        基本数据类型:变量在声明之后java就会立刻分配给他内存空间

        引用数据类型:它以特殊的方式(类似C指针)指向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。

        三、从使用方面来说

        基本数据类型:使用时需要赋具体值,判断时使用“==”号

        引用数据类型:使用时可以赋null,判断时使用equals方法


        

一、常量：值不可以改变的叫做常量。

二、变量：值可以被修改的叫做变量。

    1.声明变量（变量必须声明以后才可以使用）
        关键字（系统征用的、有特殊功能那个的单词叫做关键字）： var 声明变量
        
    2.初始化：声明变量的时候，直接给这个变量赋值叫做初始化
    3.如果我们声明变量的时候，如果没有值赋给这个变量，系统默认的就是undefined.

    常量、变量数据类型：
        （1）.基本数据类型：
            数字：
                类型： number
                例子： 100 -20 3.14 
            布尔值：
                类型：  boolean
                例子：  
                    true       真   除去0 " " null undefined NaN
                    false      假
            字符串：
                类型：string 所有带单引号或者双引号的都叫做字符串
                （单引号、双引号效果一样的，但是必须成对）
                例子：'hello'  "word" '100'

        （2）.引用(复合)数据类型     Arr(数组)

        （3）.特殊数据类型：
            null 空     不存在的对象
            undefined  没有写数值的时候 没有初始化、定义的值
            NaN(not a number)   不是一个数字


            String          String          字符串
            Number          Number          数字
            Boolean         Boolean         布尔值
            Undefined       Undefined       没有初始化、定义的值
            Null            Object          不存在的对象
            NaN             Number          Number 中的特殊数值
            Object          Function

 

    
四、标识符： 所有用户可以自定义的名字叫做标识符
    变量名也是标识符

    命名规则:
        1.只能由数字、字母、下划线、和$符号组成
        2.不能以数字开头
        3.不能是保留字和关键字
        4.区分大小写
        5.见名思意(尽量使用英文)
        6.单词个数超过两个的
            <1>驼峰式命名
                className   第一个单词首字母小写，后面的首字母大写
            <2>下划线命名
                class_name
    变量：若引用类型，赋值成什么数据类型就是什么数据了类型.accordion
    注：不建议改变当先变量的数据类型。容易引起歧义。
    
    JavaScript语句标识符
    JavaScript 语句通常以一个 语句标识符 为开始，并执行该语句。
    语句标识符是保留关键字不能作为变量名使用。
    下表列出了 JavaScript 语句标识符 (关键字) ：

        break	            用于跳出循环。
        catch	            语句块，在 try 语句块执行出错时执行 catch 语句块。
        continue	        跳过循环中的一个迭代。
        do ... while	    执行一个语句块，在条件语句为 true 时继续执行该语句块。
        for	                在条件语句为 true 时，可以将代码块执行指定的次数。
        for ... in	        用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。
        function	        定义一个函数
        if ... else	        用于基于不同的条件来执行不同的动作。
        return	            退出函数
        switch	            用于基于不同的条件来执行不同的动作。
        throw	            抛出（生成）错误 。
        try	                实现错误处理，与 catch 一同使用。
        var	                声明一个变量。
        while	            当条件语句为 true 时，执行语句块。


五、运算符
        1.算数运算符                                    
                + - * / 
                %               （取余）     
                parseInt         （取整）
        2.关系运算符                
            > < >= <=  == != === !==   等于 不等 恒等于 恒不等 （是用来进行逻辑判断的）
        3.逻辑运算符
            && || !                     与 或 非
        4.一元运算符    自加、自减一元运算符
            ++  --
        5.赋值运算符
            <1>基本运算符 =                     功能：将=号左边的值，赋值给=号右边的变量
            <2>复合赋值运算符 += -= ...x=       功能： 同时等于上值和本行加减

    不同的数据类型之间使没法进行的，计算机将数据转换成同一数据类型，再进行计算。

    （1）算数运算符自动数据类型转换：
        1含有字符串的操作分为两个：
            (1).字符串拼接:其中的一个操作必须是字符串，运算符必须是+号：则别的数据类型转成字符串进行拼接                                 。(有NaN也拼接)
            (2).任何数据和字符串做+以外的操作，那么字符串要先转成数字再去进行运算。
                <1>如果字符串是一个纯数字组成的字符串，转成相对之的数字
                <2>如果字符串中含有数字以外的别的字符，转成
                .(运算结果为NaN)
        2.除字符串以外的数据，在进行数据运算的时候，先转成数字，再进行运算
                true = 1
                fales = 0
                null = 0
                undefined = NaN
                NaN = NaN

        强制数据类型转换：
            Boolean()       将其他的数据类型强制转换成布尔值      
                            非0即真 非空即真 true   特殊数据类型转布尔值都是false

            Number（）       将其他的数据类型强制转换成数字 
                            只有纯数字组成的字符串，才能转换成数字,其他转为NaN

            parseInt        1.把字符串中字母前面的数字转为数字,把带有小数点的纯数字取整,字母前没有数字取NaN  
                            2.把小数点前面的数，取整
                            3.将别的进制转为10进制 必须传入字符串
                                    var str1 = "110100";
                                    alert(parseInt(str1,2));
                                    输出52

            parseFloat      取字符串中字母前的浮点数 （JS带小数点的数）,字母前没有数字取NaN
    
    (2)：关系运算符  是用来判断的
                >  <  >=  <=  ==     !=      ===        !==    
                                等于   不等    恒等        恒不等

        注： 关系运算符的值，绝对是布尔值 true false

    关系运算符自动数据类型转换：
        1、和其他运算符一样，当关系运算符操作非数值时要遵循以下规则：
            <1>两个操作数都是数值，则进行值比较
            <2>两个操作数都是字符串，则比较两个字符串的字符编码ASCII码
                ASCII码表： 是电脑内部，每一个字符对应的编码的一张表 
                    （1）如果是两个单个字符进行比较，直接比较字符的ASCLL码
                    （2）逐位比较，如果比较出大小，直接得结果，后续字母不用管
            <3>两个操作数有一个是数值，则将另一个转化为数值，再进行数值比较,
            另一个为不能转化为数值例如“a10”或者“aaa”的字符串string,则判断结果直接非false

        2、在等于和不等的比较上，如果操作数是非数值，则遵循以下规则
            <1>一个操作数是布尔值，则比较之前将其转换为数字（true转成1 false转成0）
            <2>一个操作数是字符串，则比较之前先转成数字再比较
            <3>任何数据和==NaN 都是false   和NaN != 都是true 包括NaN它自己
                和==NaN 都是false   
                和NaN != 都是true 
                NaN != NaN  true
                道理和一个不是苹果，另一个也不是苹果 他俩不一定相等类似
            <4>===恒等，必须数字和数据类型都相等，返回true,否则false
                alert('10'=== 10);       false   // 恒等必须值相等的同时 数据类型也要相对
            <5>null转换为数字输出0 和 undefined转换为数字输出NaN 
                与
                alert(null == undefined); 输出true 没有任何关联。


    （注3）:  逻辑运算符

        1.与运算:
            格式：
                表达式1 && 表达式2
            规律：只有两个表达式都是true的时候，整个表达式才真
            短路操作；当表达式1为false的时候，表达式2就不执行了，直接得出结果为false.

        2.或运算：
            格式：
                表达式1 ||  表达式2
            规律：只要有一个为真表达式就为真 只有两个表达式都是false的时候，整个表达式才为假
            短路操作：当表达式1为true的时候，表达式2就不执行了，直接得出结果true

        3.非运算：
            格式：
                ！表达式
            规律：现将表达式的值自动数据类型转换成布尔值，然后，再取反
                注：非0及真，非空及真 再取反


    （注4）:一元运算符  ++  功能，对原有的变量进行+1操作
        
        a++; ++后置，先取a的值作为a++的表达式，然后再对A进行+1
            
        ++a; ++前置，先对a进行+1操作，再取a的值作为表达式的值

        a--;  --先对a值的值作为a--的表达式的值，然后再对a进行-1
        --a;  --前置，先对a进行-1操作，再取a的值作为表达式的值


五、表达式：任何数据和运算符组成的式子叫做表达式。
    <1>表达式的值
    <2>表达式的功能

    例子： var a = 5;
            alert(a++);    表达式为5
            alert(a)       值为6


六、js程序的三大流程控制语句:
    （1）顺序结构：代码自上而下顺序执行
    （2）分支结构/选择结构/条件构造：要根据不同的条件，执行不同的操作
    （3）循环语句：重复去做一件事情 



    <1>、顺序语句 从上到下执行

        例子:       题目：输入两个数，然后交还这两个数字

        var num1 = 10;
        var num2 = 20;
        alert("num1:" + num1 +",num2:" +num2);
        var tmp = num1;                             //把1里的数值暂存起来        
        num1 = num2;                                //把2的数值挪到1
        num2 = tmp;                                 //把暂存的数值挪到2
        alert("num1:" + num1 +",num2:" +num2);

    <2>、选择结构

    分支语句/条件语句/选择语句：它可以用来判断 根据不同判断，执行不同内容 
        注意:if后面  自动数据类型转换为布尔值  
    
        1.选择结构-单分支语句：
            语法：
                if(判断的条件){
                    执行语句；（判断条件为true的时候执行）
                } 
        2.选择结构-双分支语句：
            语法：
                if(判断的条件){
                    执行语句；（判断条件为true的时候执行）
                }eles{
                    执行语句（判断条件是false的时候执行）
                }

            步骤：
                1.确定判断条件是什么
                2根据不同的结果，编写对应的执行语句。
            注： if()里面可以写任何东西，都会自动数据类型转换成布尔值

        3.选择结构-多分支语句：
            语法：
                if(判断条件1){
                执行语句1;
                }
                else if(判断语句2){
                    执行语句2;
                }
                ...
                else{
                    执行语句;       （上述所有条件都不成立，执行这里）
                } 

        4.三目运算符：    
                格式：
                    表达式1？ 表达式2： 表达式3;
                执行：
                    1.先去判断表达式1是否为真
                    2.表达式1为真，直接去执行表达式2
                    3.表达式1为假，直接去执行表达式3

                注：本质上就是一个双分支语句 

                例子：
                    var num = 8;
                    num % 2 == 0 ? alert("偶数") : alert("奇数");

        5.选择结构-switch语句 它可以用来匹配
            switch语句：用来匹配
                它不会把switch()里面的表达式不会自动数据转换成布尔值，而是直接会计算计算表达式结果
                    语法：
                        switch(表达式){
                            case 匹配常量1:
                                执行语句1;
                                break;
                            case 匹配常量2:
                                执行语句;
                                break;
                            ...
                            default:
                                当上述所有的case选项都匹配失败，执行这里。
                                break;
                    过程：
                        1.计算switch()语句表达式的值
                        2.和case后续的值进行匹配，匹配承给，执行。
                    注意：
                        1.一般情况下不要省略break;
                            break代表的是终止当前switch语句
                        一般情况下不要省略default;它可以帮助我们检查报错。
                        alert("error");
                        break;
                            
    <3>循环控制语句 ：   
                （1）.while循环     
                （2）.do_while循环        
                （3）.for循环

        1.while循环：
            格式：
                while(循环条件){
                    循环语句；
                }
            执行：如果循环条件成立就执行循环语句，直到循环条件不成立为止,循环条件为ture的时候一直执行


        步骤：
            1.确定循环的次数。
                注：循环条件，while()可以写任何表达式，最后都会自动数据类型转换成布尔值
                注：不能让循环条件永远成立，会造成死循环
            2.确定好每次循环的代码


        注：while循环与do_while的区别:
                1.while循环 先判断循环条件，再看是否执行
                2.do_while循环，先进行一次循环，再判断循环条件 



        2.do_while循环:
            格式：
                do{
                    循环语句
                }while(循环条件);
        
        3.for循环：
            格式：
                for(表达式;表达式2;表达式3){
                    执行语句;
                } 

    延申：循环中的 birak          功能：终止 当前循环
                    
                continue       功能：跳过这次循环，直接进入下次循环

    延申：       Math.ceil()    功能：不管小数点后面数有多小，直接向上进1取整
                                例如Math.ceil(3.01) == 4 


函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数函数

    JS常用函数名
        req (request)   请求
        res (response)  响应
        arr             数组
        str             字符串
        sum             合计数
        show            显示
        speed           速度
        count           计数
        item            项目
        node            节点
        attr            属性
        type            类型
        value           值
        elements        元素
        create          创造
        child           子项/孩子
        parent          起源/父母亲
        append          追加
        insert          插入
        inset           镶嵌(在图像、图形、)
        menu            菜单
        const           常量
        Set             集合




    js函数      程序员写的       
    调用函数    函数才会执行

一、函数的语法

    1.无参数无返回值函数的语法：
        函数声明：(无参数无返回值)
            function 函数名(){
                函数体;                              //具体需要执行的代码
            }
            注：面名思意函数名必须体现其功能

        函数调用：
            函数名()

    例子：输出10个hello world

         function print(){
            for(var i = 0; i < 10; i++){
                document.write("hello world </br>");
            }
        }
        
        print();                每调用一次参数，就会增加一组(10个hello world)
        


    2.有参数无返回值的函数语法
        注：把函数处理调用结果写在函数里面，不用return传出返回值
        函数声明：
            function 函数名(形参1，形参2....){
                函数体;
            }
            
        调用函数：
            函数名(实参1，实参2....);

        形参：声明的时候先假设的一个参数           注：使用起来和普通的变量没有区别
        实参：调用的时候实际的参数
        传参：用实参给假设的形参赋值的过程叫做传参

        例子:
            function print(n){
            for(var i = 0; i < n; i++){
                document.write("helllo word </br>");
            }
        }

        print(5);               输出5个hello world


    3.有参数有返回值的函数
        注：我们可能对参数的运行结果有不同的处理，所以不能将函数运行的结果写在函数里面进行最终调用，
        不然限制了我们想要实现的各种功能。
        
        注：return后面写什么表达式，函数调用的结果就是什么，但是不要写和函数无关的内容，这样没有意义。
        我们一般在函数里面return后面写函数的运算方式、或结果，然后在外部根据各种需求写各种样式：通过
        用实参给形参传参的方式调用return，这样就实现了我们各种对函数，运算结果的不同处理方式。
        如果没有写return的话调用结果为undefined。
        
        注：函数运行的时候遇见return，函数运行就会终止。 

        封装函数的步骤：
            1.分析不确定值
            2.将不确定值声明成形参
            3.函数名和形参要见名思意

        return 关键字
        有参数有返回值的函数：  
            格式：
                function 函数名(形参1、形参2....){
                    函数体;
                    return 表达式;
                }

            调用： 
                alert(函数名)；
                 
            显示结果:
                return 表达式;


二、函数arguments:
     每一个函数内部都会有一个arguments，系统内置的。arguments是用来储存实际传入的参数。

        属性： arguments.length  输出当前存储的参数个数。
           
        访问某一个数据：  arguments[下标];   注：下标是从0开始的。

        注：优先使用形参，除非特殊情况不知道参数个数 

    例子：  
        function show() {
            alert(arguments.length);        //参数个数为4个
            alert(arguments[1]);            //[1]  对应着4个参数中的 true
        }

        show(10, true, "hello world", 40);   
             
    思考；为什么要用arguments来储存传入的参数？
    
    原因：   正常一个函数函数它要去传一个实参的话，是通过形参去接，中间有一个传参的过程，而这个传参的过程
    就是用实参来给形参赋值，但是呢，不是说所有的函数它都能够通过形参去接的。

    比如一个例子：求传入任意个数字的和。

    声明一个参数可能不够，声明多个参数也可能不够，因为不能满足任意一个数字。
    arguments不管来多少都可以先存在一个变量里面，所以可以通过arguments来处理这种极端的情况。
    但若从一开始就知道有多少个参数的话，尽量不要用arguments来处理，这不符合见名思意。

    
三、函数的作用域：
        任何程序在执行的时候都要占用内存空间，函数调用的时候也要去占用内存空间

            调用函数的时候，系统会分配对应的空间给这个函数使用。(空间大小，一般由
            这个函数声明的变量和形参决定的)当函数使用完毕以后，这个内存空间要释放，
            还给系统。

            注：在函数内部声明的变量和形参是属于当前函数内存空间里面的。

            内存管理机制：在函数中声明的变量和形参，会随着函数的调用被创建，随着函
            数的调用结束而被销毁，函数中声明中的变量和形参，有限范围是当前函数(当前
            函数的大括号)，作用域，局部起作用。所以不会影响外部硬盘空间的全局变量，
            如果函数内部没有参数，才会影响外部全局变量


            就近原则：离那个作用域近，就使用哪个作用域内部的同名变量

            （1）函数作用域 function{ }，块级bai作用域 {}。
            一定要有du function 关键字，zhi才会有函数作用域。
            （2）js里面 var声明的变量只有函数作用域，没有块级作用域。
            也就是说，函数可以用var隔离变量(除非不写var直接声明变量)，for不能用var隔离变量。
    
    例子1：
        var a = 2;                 //声明在全局的变量叫做全局变量
            function show(){         
                a++;
                alert(a);
            }
                                    //先在硬盘开辟一个空间声明 a=2    
            show();                 //调用函数的同时使用 a++ = 3  函数空间删除    修改硬盘空间a=3    
            show();                 //调用函数的同时使用 a++ = 4  函数空间删除    修改硬盘空间a=4    
            alert(a);               //因为修改过硬盘空间全局变量a=4 所以显示显示a=4  

    例子2：
        function show (){
                var a = 2;          //局部变量
                a++;
                alert(a);
            }
            show();                 //调用函数空间a++ =3 之后删除函数空间 a=3 消失 
            show();                 //调用函数空间a++ =3 之后删除函数空间 a=3 消失 
            alert(a);               //a没有 所以系统报错  

    例子3：
        var a = 10,
            b = 20;

        function show(a) {
            var b = 100;            
            a += 5;                 
            alert(a + "," + b);
        }
        show(a);                //函数内部产生一个形参a 因为函数外部a=10的传参赋值，所以实参a=10， 
                                //函数内部和外部分别有一个a,根据就近原则，选择函数作用域内部a+=5 所以==15 
                                //在函数内部a=15，不影响外部硬盘空间a=10    所以显示a=15 b=100
        alert(a + ", " + b);    //10，20 调用函数结束 函数空间删除 只剩下外部 a=10 b=20  



    例子4：
        var a = 10,
                b = 20;

            function show(a) {
                b++;            
                a += 5;                 
                alert(a + "," + b);
            }
            show(a);                //因为没有内部局部变量b,所以b++影响外部全局变量b=21
            alert(a + ", " + b);    //删除函数后 a不受影响=10 b之前受过影响=11 所以显示 a=10 b=21


        总结：
            1.外部有全局变量，函数内部无局部变量，影响全局变量
            2.外部没有全局变量，函数内部有局部变量，不产生也不影响全局变量
            3.外部有全局变量，函数内部有局部变量,先影响内部的变量，内部没有的部分才影响外部全局变量



数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?数组?


    数组：用一个变量储存一堆数据的数据结构。
    数据类型：
        【引用】数据类型   
        数组，数组的变量储存的是数组的地址

        运行程序：
        1.准备运行程序需要的空间(一旦分配好以后，内存大小没法进行改变了)
        2.开始运行程序

        例子1：
            var arr1 = [10,20,30,40];
            var arr2 = arr1;
            arr2.push(50,60);
            alert(arr1);        //10,20,30,40,50,60
            alert(arr2);        //10,20,30,40,50,60

        例子2： 
            var arr1 = [10,20,30,40];
            var arr2 = arr1.concat();       //concat()拷贝原数组，生产一个新数组
            arr2.push(50,60);
            alert(arr1);                    //10,20,30,40
            alert(arr2);                    //10,20,30,40,50,60


        (1). 声明数组：
                1.通过new创建数组
                    参数：传入任意的数据，储存到数组中

                2.省略new运算符创建数组


                3.数组常量进行赋值。(JS一般使用中括号[] )
                

            <1>    var arr = new Array(100, true, "hello");
            <2>    var arr =  Array(100, true, "hello");
            <3>    var arr = [100, true, "hello"];
                   alert(arr);

            注释：上述前两种方式，传入参数只有一个，并且是数字的时候，直接声明这么长的一个数组

                    //声明长度为10的数组，数组中没有数据，但是占据10个位置
                    var arr = new Array(10);
                    var arr = Array(10);

                    //这个数组里面只有一个常量，这个常量数据是10
                    var arr = [10];

        （2）数组的属性：
                数组.length     返回值数组元素的个数

                元素：将数组储存的每一个数据，叫做数组的元素

                访问数组的元素：
                    数组[下标];     下标是从0开始的


                var arr = [100, true, "hello"];
                alert(arr.length);                 //返回值数组元素个数为3
                alert(arr[1]);                     //从0开始 1的数组元素为true


                注：数组和循环是天生的一对

                        var arr = [100, true, "hello"];
                        for (var i = 0; i < arr.length; i++) {
                        document.write(arr[i] + "</br>");
                }

            练习：数组随机数

            Math.random()                                   随机0~1之间(无线接近1，但不会出现)
            parseInt(Math.random()*10);                     限定随机0~9的整数


            var arr = new Array(10);
                for (var i = 0; i < arr.length; i++) {      
                    arr[i] = parseInt(Math.random() * 10);
                }
                alert(arr);                                 随机显示一组10的0~9之间的随机数

        (3).数组遍历：
                遍历：类似一个班的同学，开头从0开始报数，全班同学报一遍

            for循环                                                 通过元素下标遍历
            for...in    for(var i in arr){}                         快速遍历
            forEach     arr.forEach(function(item, index, arr){});  通过元素和下标遍历
            for...of    for(var item of arr){}                      通过元素遍历，没有下标,item为遍历到的元素 

                例子：
                    var arr = [10,20,30,40,50];

                    for(var i =0; i<arr.length; i++){
                        document.write(arr[i] + "</br>");
                    }


                    for(var i in arr){                          //不需要计算和判断，直接显示
                        document.write(arr[i] + "</br>");
                    }

        (4).数组的方法：

            1.栈结构方法：
                栈：木盆
                结构
                结构：从一头进，从同一口出
                特点：先进后出

                数组的两个方法形成栈结构：
                    push：
                        末尾进元素   
                        格式：  数组.push(参数1,参数2...);
                        功能：  给数组的末尾添加元素。
                        返回值: 插完元素以后数组的长度
                    
                    pop
                    末尾取元素
                    格式：  数组.pop{}
                    参数：  没有参数                即不能指定元素，只能按顺序取
                    功能：  从数组末尾取下一个元素
                    返回值：取下一个元素

            2.队列结构方法：
                        结构：从末尾进，从头部出
                        特点：先进先出

                        push 
                            末尾进元素

                        unshift()
                            格式：数组.unshift(参数1,参数2...)
                            功能：从数组的头部输入元素
                            返回值：插完元素以后数组的长度

                        shift
                            从头部取元素
                            格式：数组.shift()
                            参数：没有参数              即不能指定元素，只能按顺序取
                            功能：从头部取下一个元素
                            返回值：取下的元素

            3.concat()方法：    
                        拷贝原数组，与其他数组合并，生产一个新的数组，原来的数组不会被改变
                        
                            格式：数组.concat(数组,或者单个的新数据....);
                            返回值：合并新生成的数组，原数组不会被改变。

                        注释：就算传入的是数组，数组中元素中的元素要单独拆出来再进行合并

            4.slice()方法：
                        格式：数组.slice(start,end);  (开始，结束) ()里面是元素的下标
                        
                        注意：()里面下标从0~N开始，结束位置元素不会提取出来
                        功能：可以基于当前数组获取指定区域元素(start.end),去除元素生成新数组
                        返回值：生成的新数组，原数组不会改变

                        arr[0 1 2 3 4 5 6]
                        arr.slice(0,3)              只会取 0 1 2 

            5.splice()方法：
                        功能：
                            增加        (增加的位置,0,增加的元素)

                            删除        (删除的位置,删除的数量 )
                                        也可以理解为截取

                            修改        (修改的位置,修改的数量,修改后显示的元素）
                                        机制是先删除后增加


                            格式：数组.splice(start,length,数据1,数据2...);

                            参数：
                                start:  开始截取的位置（插入增加、删除、修改）
                                length: 截取元素的个数  0为不截取，直接插入
                                第三个元素开始：在start位置，插入的元素。

                            返回值：截取下来的元素组成的数组。
                            注：增加的截取元素为0，所以返回值显示空白。

            6.join()方法：
                        格式：  数组.join(字符串);
                        功能：  将数组中的元素,用传入的拼接符，拼接成一个新的整体字符串
                        返回值：拼接好的字符串  

            7. reverse()方法     
                        格式：reverse(需要元素反方向改变顺序的数组);
                        功能：下标逆序  
                        返回值：逆向顺序的数组

            8.sort()方法：
                        会改变原来数组的顺序
                        功能：数组排序,默认从小到大排序，按照字符串排序
                        格式：数组.sort     
                        参数：一个函数，代表怎么去排序。(固定用法)
                        注意：因为是根据ASCII码值表排列，所以位数不同的话，排列顺序可能不会从小到大

                        例子1：//显示10,20,30,40,50,60
                        var arr = [30,20,50,10,40,60];
                        arr.sort();
                        alert(arr); 
                        

                        例子2： //10，15，20，25，5 先比较字符串第一位，5最大，所以在后面 hello的ASCII值最大
                        var arr = ["hello",1,10,20,15,25,5,];
                        arr.sort();
                        alert(arr);
                    

                        例子3： //按数值从小到大排序

                        
                        var arr = [1, 10, 20, 15, 25, 5, ];
                        arr.sort(function (value1, value2) {
                        return value1 - value2;
                        });
                        alert(arr);

js 声明提升: 作用在当前作用域，声明变量和函数，会直接提升到整个代码的最前面运行
        特点：
            内存分配，一次分配

            准备做菜，先要将菜谱从头到尾看一遍，所以材料准备好，接着才开始工作

            预编译：在所有代码运行之前，计算机将代码从头到尾看一遍，将这个程序需要运行的空间一次性分配好

            函数也会声明提升


    例子1： var num;

        alert(num);                     //undefined
        var num = 10;                   //num = 10;
        alert(num);                     //10

    例子2：
         function show(){
            alert(num);                 //undefined
            var num = 10;
            alert(num);                 //10
        }

        show();
        alert(num); //报错，因为它不是函数内部


js省略var:

    直接强制给一个变量赋值，这个变量会被Js强制声明成全局变量
    【注】：不建议，着属于语法错误

    例子：
        function show(){
            num = 10;       
            alert(num);
        }

        show();
        alert(num);     //因为是全局变量所以也会显示10

严格模式：
    除了正常运行模式，script-ECMA5添加了第二种运行模式："严格模式"（strict mode）。
            顾名思义，这种模式使得Javascript在更严格的条件下运行。
            设立"严格模式"的目的，主要有以下几个：

            　　1 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;

            　　2 消除代码运行的一些不安全之处，保证代码运行的安全；

            　　3 提高编译器效率，增加运行速度；

            　　4 为未来新版本的Javascript做好铺垫。

                "严格模式"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，
                都已经支持它，许多大项目已经开始全面拥抱它。
 
            进入"严格模式"的标志，是下面这行语句： "use strict";
            尽量不要全局使用严格模式，否则引用外部别人写的src js会受到影响
            影响：
                1.声明局部变量时，必须加var
                2.this无法指向全局对象
                3.函数内重名属性不被允许
                4.arguments对象不允许被动态改变
                5.新增保留字：imlements interface let package private protected public static yield
                    
    严格模式下新增的数组方法：
    一、查找
            功能：在数组中查找第一次出现item元素的下标，从start开始查找
            1.indexOf()     
                    格式：数组.index(item, start);
                    item：  任意的数据   
                    start： 下标 可以不传入，默认为0
                        
                    注意：只查找第一次出现的下标，即只能查找一个
                    注意：-1 没有查找到下标
            例子：
                var arr = [10, 20, 30, 40, 50, 20, 30];
                var index = arr.indexOf(120, 2);
                alert(index);

    二、遍历
            2.forEach   
                arr.forEach(function(item, index, arr){});
                    item    当前遍历到的元素
                    index   当前遍历到元素的下标
                    arr     数组本身
                
            例子：
                var arr = [10, 20, 30, 40, 50];
                arr.forEach(function(item, index, arr){

                });

                    
            3.map   映射遍历

                arr.map(
                    function(item, index, arr){
                        return item修改条件
                })；
                多了一个可以在return处，修改遍历出元素的值的内容

                映射：可以根据一段固定的运算公式，把原来的数根据运算公式，
                直接算出运算结果，放在和原来一模一样下标的一个数组里
                

            例子：
                var arr = [10, 20, 30, 40, 50];
                var newArr = arr.map(function(item, index, arr){
                
                    return item * 1.3;
                });
                alert(newArr);
                alert(arr); 

    三、过滤
            3.filter    

            功能：响应筛选出符合条件的元素
            item    当前遍历到的元素
            index   当前遍历到元素的下标
            arr     数组本身
            
            arr.filter(
                function(item, index, arr){
                    return  过滤条件(找出符合条件的元素,输出)
                }
            );

            例子：
                var arr = [10, 20, 30, 40, 50];
                var newArr = arr.filter(
                    function(item, index, arr){
                        return item > 20;
                    } 
                );

            
            4.some      某些

            注释：在数组中查找是否有符合条件的元素 有返回true,没有返回false
            短路操作：只要找到符合条件的元素，后面的循环就停止了

            arr.some(
                function(item, index, arr){
                    return irem 过滤条件(根据条件进行判断，有符合条件的进行输出为turn)
                }
            );

            例子：
                var arr = [10, 20, 30, 40, 50];
                var newArr = arr.some(
                    function (item, index, arr) {
                    return item > 20;
                });
            

            5.every   每一个
            
            注释：在数组中查找出每一个元素是都否符合条件，符合返回true，不符合返回false
            短路操作：只要找到不符合条件的元素，后面的循环就停止了

            arr.ever(
                function(item, index, arr){
                    return item 过滤条件(依据条件判断，所有元素是否都符合条件，符合返回true)
                }
            );

        四、归并
            6.reduce
                prev 第一次是 下标为0的元素  第二次是上一次遍历return的值
                next 从下标1开始，当前遍历到的元素
                arr  数组本身
                return过程 从下标1开始，每一次都是本元素前所有元素的和 与 本元素

            arr.reduce(function(prev, next, index, arr){
                return prev + next;
            };

认识字符串
    1.字符串概念：所有带有单引号或者双引号都叫做字符串
            字符串声明:
                1.通过new运算符去声明字符串
                2.省略new声明字符串
                3.字符串常量赋值
                
        例子：
            var str1 = new String(100);
            var str2 = String(100);
            var str3 = "100";
            alert(typeof str1); //object    对象，引用数据类型
            alert(typeof str2);//string
            alert(typeof str3);//string

    2.访问字符串中的字符
                字符串.length   访问字符串中字符的个数
                注意：中文 UFT-8(三个字符串表示一个字符) gkb(两个字符表示一个汉字)
                在计数的时候都是当作一个汉字计数

            访问字符串中单个字符：
                字符串.charAt(下标)     【注】从0开始
                字符串[下标]

            【注】字符串是只读，字符串一旦被声明就没办法修改，非要修改我们只能将原字符串销毁，重新生成新的字符串
            【注】字符串既是基本数据类型、又是复合数据类型

    例子：
        var str1 = new String(100);
        var str2 = String(100);
        var str3 = "100";
        alert(typeof str1);         //object    对象，引用数据类型
        alert(typeof str2);         //string
        alert(typeof str3);         //string

    3.字符串的方法：
        1.必须在document.write()中使用,一般很少用，因为html与CSS更方便实现这些功能
        big()               用大号字体显示字符串
        blink()             显示闪动字符串(IE下无效)
        bold()              使用粗体显示字符串
        fixed()             以打印机文本显示字符串
        strike()            使用删除线来显示字符串
        fontcolor()         使用指定颜色蓝显示字符串
        fontsize()          使用指定尺寸蓝显示字符串
        link()              将字符串显示为链接
        sub()               把字符串显示为下标
        sup()               把字符串显示为上标


        2.字符串的遍历方法：
            字符串中的字符进行遍历也可以通过循环遍历
        例子：
            var str = "hello北京";
            for (var i = 0; i < str.length; i++){
            document.write(str[i] + "<br/>");
            }

        3.寻找字符串中ASCII码值发明回复

            charCodeAt()
                格式：字符串.charCodeAt(下标);
                功能：访问字符串中对应下标的ASCII码值, 即把字符串转为ASCII


            String.fromCharCode();
                格式：String.fromCharcode(码值1，码值2....);
                功能：将传入的ASCII码值转成对应的字符,即把ASCII转为字符串             
                返回值：组成的字符串

        例子：
            var str = "hello";
            alert(str.charCodeAt(1));               //下标(1)是e ASCII码是101

            var str = String.fromCharCode(97, 98, 99, 100);
            alert(str);                             //ASCII码 97 对应的是a  相应显示abcd

        4.字符串的查找方法
            indexOf()
                功能：在supStr中查找subStr第一次出现的位置下标，从start这个位置开始查找
                格式：supStr.indexOf(subStr, start);
                返回值：-1 说明没有超找到
                参数：
                    第一个参数，查找
                    start 从那个下标开始查找，如果不传入，默认从下标0开始查找

            lastIndexOf()
                功能：在supStr中查找subStr最后一次出现的位置
                格式：supStr.lastIndexOf(subStr);
                参数：第二个参数是开始查找的位置，查找是从右往左数的
                返回值：-1 说明没有超找到
            
            search()
                功能：在supStr中查找subStr第一次出现的位置
                格式：supStr.search(subStr);
                参数：字符串/正则表达式
                返回值：-1 说明没有超找到
                正则表达式：
                    修饰符： i忽略表达式（如：大小写）  g执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
                            m执行多行匹配。

        例子
            var supStr = "abcabcabc";
            var subStr ="abc";
            var index = supStr.indexOf(subStr,4);
            alert(index);                   //从下标4开始查询，匹配abc的是从下标6开始的元素

            var supStr = "abcabcabcabcabcabc";
            var subStr ="abc";
            var index = supStr.lastIndexOf(subStr,17);
            alert(index);                  //从后往前下标17开始查找，匹配abc的是下标17的元素为最后一次出现位置

            var supStr = "Abcabcabc";
            var subStr ="abc";              //第一次匹配是下标3 
            var subStr = /abc/;             //第一次匹配是下标3 
            var subStr = /abc/i;            //因为是忽略表达式大小写，所以第一次匹配是下标0
            var subStr = /abc/g;            //因为是全局匹配，还是区分大小写，所以第一次匹配是下标3 
            var index = supStr.search(subStr);
            alert(index);

    5.字符串的提取方法

        substring
                格式：字符串.substring(start, end);
                功能：将字符串中(start, end) 提取这部分字符，生成一个新字符串
                返回值：新生成的字符串
                参数：
                    start开始提取的位置， 
                    end结束提取的位置，不会提取end本身

            substr
                格式：字符串.substr(start, length);
                length:提取的元素长度
                返回值：新生成的字符串

            slice(是数组的方法，这里也可以用)
                格式：字符串.slice(start, end);
                参数：
                    strart开始提取的位置， 
                    end结束提取的位置，不会提取end本身


            注意： 没有长度length、或者结束end, 直接从下标start开始提取到结束
                    substring(start);
                    substr(start);
                    slice(start);
    
    例子
        var str = "hello";
        var newStr = str.substring(1,4);        //ell
        var newStr = str.substr(1,4)            //从下标1开始提取4个长度 ello
        var newStr = str.slice(1,4);            //ell


    6.字符串的替换
        replace()
            格式 supStr.replace(oldStr, newStr);
            功能：用newStr将oldStr，替换掉，生成一个新的字符串，元字符不会被改变
            返回值：替换成新的字符串。
            参数： 
                第一个参数传入的是字符串只能替换一次
                第一个参数 正则表达式
                    /XXX/   i忽略大小写     g全局匹配 

        例子
            var str = "how are aRe are you";
            var newStr = str.replace(/are/ig, "1");     
            //  are全部替换成1， 全局匹配+忽略大小写显示：how 1 1 1 you

    7.字符串的分割
        split()字符串分割成数组 
            功能：用分割符对原字符串进行分割，将分割完毕的字符串，放在数组中返回 
            格式：字符串.split(分割符，length);
            参数：
                第一个参数，用这个分割符对元字符进行分割
                第二个参数，控制返回数组的元素个数，一般情况下不用，所以不写
            注意：
                1.相邻的两个分割符 " "    会产生空字符串
                2.分割符是空字串   ""     直接分割每一个字符,单独分割成字符串，放在数组中返回

        例子
            var str = "how are you";
            var arr = str.split(" ");       //显示how,are,you因为只有一个空格，在空格左右各来一刀 

            var str = "how  are you";
            var arr = str.split(" ");       //显示how,,are,you因为有两个空格，所以两个空格之间会再产生一个新的分隔符

            var str = "how are you";
            var arr = str.split("");        //显示h,o,w, ,a,r,e, ,y,o,u因为""单独拆分每一个字符包括空格也都拆除

    8.字符串的拼接
        concat()
        字符串+字符串

        注：两种效果一样

        例子
            var str1 = "hello";
            var newStr = str1.concat("world", 100);     //helloworld100
            var newStr = str1 + "world" + 100;          //helloworld100

总结：
    substring(start, end);                         字符串提取,生成一个新的字符串     
    slice(start,end)                               数组、字符串提取，生成一个新的数组
    splice(start, length, 需要插入的数据)           数组增加、删除、修改，生成一个新的数字
    split(分割符，length需要添加的字符串元素个数);   字符串分割成，一个新的数组
    replace(oldStr, newStr);                      字符串替换掉，生成一个新的字符串
    join("")                                      将数组中的元素,用传入的拼接符，拼接成一个字符串


对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象对象

    getElementById() 方法可返回对拥有指定 ID 的第一个对象的引用。

    语法:
        document.getElementById(id)

    innerHTML 属性设置或返回表格行的开始和结束标签之间的 HTML。
    语法:
        tablerowObject.innerHTML=HTML

        表单元素：获取其中内容，        通过node.value的属性
        双标签节点：获取标签间内容，    innerHTML属性

    事件驱动函数：    
                onclick          点击按钮
                onblur.函数      失去焦点  

    默认加载完body之后运行的内容
                widnow.onload = function(){}


对象
    1.发展历史
            汇编语言：汇编 c语言 面向过程语言
            编码语言：Java、C++、JavaScript、Object-c、python   面向对象的语言
        
        2. 思想
            面向过程编程思想:只考虑数学逻辑
            面向对象编程思想:直接将生活逻辑映射到我们的程序
                <1>分析有哪些实体
                <2>设计实体属性和功能
                <3>实体之间相互作用

        3.语法(在javaScript 没有类这个概念，只有对象，ECMA6新增了类的概念)
        类：一类具有相同特征事物的抽象概念。
        对象:具体某一个体、唯一的实例

            类      对象
            狗      你遇到的那只
            电脑    你桌上那台
        
        4.代码
                对象的代码

        5.数据结构
                基本数据类型(储存一个值)    数组(处理批量数据)      对象(既可以存储数据又可以存储函数)

声明对象
    1.通过new运算符声明对象
            2. 通过省略new
            3. 对象常量赋值 (使用大括号，代表对象)

    例子
            var obj1 = new Object();
            var boj2 = Object();
            var obj3 = {};

    2.声明对象属性：使用起来和普通的变量没有任何区别
            obj.username = "钢铁侠";
            obj.age = 18;
            obj["username"] = "钢铁侠";     [""]填写属性必须使用字符串

    3.新增函数方法：使用起来和普通函数没有任何区别
            obj.show = function () {
            alert("我的名字叫做" + obj.username + "，今年" + obj.age + "岁")
        }

            obj3["show"] = function () {
            alert("我的名字叫做" + obj3.username + "，今年" + obj3.age + "岁")
        }

            obj["show"]();     //调用

            obj3.show();       //调用

    4.通过常量统一赋值
        var obj4 = {
                username:"钢铁侠",
                "age":18,
                show:function(){
                    alert("我的名字叫做" + obj4.username + "，今年" + obj4.age + "岁");
                }
            };

    5.删除对象的属性或者方法
            delete obj.需要删除的内容;

    例子
            delete obj4.username;
            delete obj4.show;
            alert(obj4.username);  //undefined
            obj4["show"]();        //直接报错，告诉不是一个函数
           
Math对象

     js中一切皆对象

            【注意】在JS，很多关系运算符的函数，直接一个Math对象提供

            【注】很多，需要查阅文档
            
    格式：
        Math.random()   

            random()	返回 0 ~ 1 之间的随机数
            max(x,y)	返回 x 和 y 中的较大数
            min(x,y)	返回 x 和 y 中的较小数
            abs(x)	    绝对值
            round(x)	四舍五入为最接近的整数  (四舍五入成整数，只看小数点后一位 例：5.49 = 5    5.5 = 6)
            ceil(x)	    向上取整
            floor(x)	向下取整
            pow(x,y)	返回 x 的 y 次幂
            sqrt(x)	    返回数的平方根
            sin(x)	    返回数的正弦    传参不是数字，是弧度 （Math.PI=180弧度） 1弧度 = Math.PI / 18;
            cos(x)	    返回数的余弦
            tan(x)	    返回角的正切
            asin(x)	    返回数的反正弦值
            acos(x)	    返回数的反余弦值
            atan(x)	    以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值
            atan2(y,x)	返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）
            exp(x)	    返回 e 的指数
            log(x)	    返回数的自然对数（底为e）
            toSource()	返回该对象的源代码
            valueOf()	返回 Math 对象的原始值


日期对象声明

    1.没有传入参数，默认当前系统时间
        Sun Sep 06 2020 20:16:24 GMT+0800 (中国标准时间)
        GMT 格林尼治时间 子午线时间

    2.传入参数
        1 "2000-01-01"
        2 "2000/01/01"
        3 按照顺序，分别传入参数  年 月 日 时 分 秒 毫秒 （注：国外月份是从0开始的 0~11月）
        4 直接传入毫秒数 1秒= 1000毫秒   (以1970年1月1日 0:0:0 为参照时间去进行换算)
            彩蛋 linux的创始人

    例子
        var  d = new date()                             //获取当前时间
        var  d = new Date("2000-01-01");
        var  d = new Date("2000/01/01");
        var  d = new Date(2000, 0, 1, 8, 30, 50);       //Sat Jan 01 2000 08:30:50 GMT+0800 (中国标准时间)
        var  d = new Date(1000);                        //Thu Jan 01 1970 08:00:01 GMT+0800 (中国标准时间)

    3.日期时间系统定义方法
        例子var d = new Date("2000-01-01");

        d.toLocaleDateString();                         //2000/1/1
        d.toLocaleTimeString();                         上午8:00:00
        d.toLocaleDateString() + " " + d.toLocaleTimeString();  /2000/1/1 上午8:00:00

        注：也可以自己自定义设置
    
    日期对象的方法

        set     设置，把其中一项重置掉 
        get     获取，把其中一项提取出来
        
            var d = new Date();                   获取当前日期
            var year = d.getFullYear();           获取年
            var month = d.getMonth() + 1;         获取0~11月    按照中国习惯+1
            var date  = d.getDate();              获取日
            var week = d.getDay();                获取0~6 0是周日
            var hour = d.getHours() ;             获取小时
            var min = d.getMinutes() ;            获取分
            var sec = d.getSeconds();             获取秒


















            

    4.日期对象转换成毫秒方法

        注意：所有参照时间点都是1970年

            Date.parse()
                格式： Date.parse(日期对象)
                功能： 可以将日期对象与1970年1月1日的差转换成毫秒数


            d.getTime() 
                格式：
                    日期对象.getTime() 
                功能： 可以将日期对象与1970年1月1日的差转换成毫秒数
            
            d.setTime()
                格式：
                    日期对象.setTime()
                功能：重设距离1970年1月1日的毫秒数 
                例子：d.setTime(1000);      //Thu Jan 01 1970 08:00:01 GMT+0800 (中国标准时间)

定时器
    格式：
        var timer = setInterval(函数, 毫秒数);
    功能：
        每隔对应的毫秒数，执行一次传入的函数
    返回值：
        timer 启动定时器的，系统分配编号 

    claerInterval(timer);   取消定时器

    例子：
        var i = 0;
            function show(){
                if(i == 5){
                    clearInterval(timer);
                }
                document.write(i++ + "<br/>");
            }

            var timer = setInterval(show, 1000);

    另一种写法：
        var i = 0;
        var timer = setInterval(function(){
            if(i == 5){
                clearInterval(timer);
            }
            document.write(i++ + "<br/>");
        }, 1000);
    
    总结：
        一般情况下没有名字的函数叫做匿名函数
        var timer = setInterval(匿名函数，毫秒数)；
        var timer = setInterval(function(){
            执行代码;
        }, 毫秒数);

匿名函数
    匿名函数是一个没有函数名的函数。

    匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。

    我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。

    语法格式如下：
    var res = function( ) { ... }

    
    function res(){
            console.log("我是有名函数");
        }

BOM：browser object model 浏览器对象模型：

常见的BOM对象
    window：代表整个浏览器窗口（window是BOM中的一个对象，并且是顶级的对象）

    History：代表浏览器的历史信息，通过History我们可以实现上一步/刷新/下一步操作（
    出于对用户的隐私考虑，我们只能拿到当前的浏览记录，不能拿到所有的历史记录）

    Location： 代表浏览器当前的地址信息，通过Location我们可以获取或者设置当前的地址信息

    Navigator ：代表浏览器当前的信息，通过Navigator我们可以获取用户当前使用的是什么浏览器

    Screen：代表用户的屏幕信息


Window对象方法：

    alert()：弹出一个警告框

    confirm()：弹出一个确认框

    prompt()：弹出一个提示框

    open()：打开一个新窗口

    scrollTo()：滚动到指定位置

    setTimeout()和clearTimeout()        延时器
        setTimeout()    方法用于在指定的毫秒数后调用函数或计算表达式。
        clearTimeout()  停止

    setInterval()和clearInterval()      秒表
        setInterval()   如果你只想重复执行可以使用方法。
        clearInterval() 停止

    定时器
            格式：
                var timer = setInterval(函数, 毫秒数);
            功能：
                每隔对应的毫秒数，执行一次传入的函数
            返回值：
                timer 启动定时器的，系统分配编号 

            claerInterval(timer);   取消定时器




    系统对话框
        window 方法(一般情况下window可以省略)

            alert() 弹出警告框

            confirm() 弹出一个带确定和取消的提示框
                返回值：
                    如果点击确定，返回true
                    如果点击取消，返回false

            prompt() 弹出一个带输入框的提示框
                参数：
                    第一个参数：输入框上方的提示内容
                    第二个参数：输入框里面的默认值(可以不传入)
                返回值：
                    如果点击确定，返回输入框的内容
                    如果点击取消，返回null

            open()
                    第一个参数：跳转url 打卡一个新的窗口，加载URl
                    第二个参数，字符串，给打开的窗口起一个名字，再次点击可以直接找到这个窗口
                    第三个参数，一串特殊含义的字符串
                        left=pixels	窗口的 x 坐标。以像素计。
                        top=pixels	窗口的 y 坐标。
                        height=pixels	窗口文档显示区的高度。以像素计。
                        width=pixels	窗口的文档显示区的宽度。以像素计。
                        channelmode=yes|no|1|0	是否使用剧院模式显示窗口。默认为 no。
                        directories=yes|no|1|0	是否添加目录按钮。默认为 yes。
                        fullscreen=yes|no|1|0	是否使用全屏模式显示浏览器。默认是 no。处于全屏模式的窗口必须同时处于剧院模式。
                        location=yes|no|1|0	是否显示地址字段。默认是 yes。
                        menubar=yes|no|1|0	是否显示菜单栏。默认是 yes。
                        resizable=yes|no|1|0	窗口是否可调节尺寸。默认是 yes。
                        scrollbars=yes|no|1|0	是否显示滚动条。默认是 yes。
                        status=yes|no|1|0	是否添加状态栏。默认是 yes。
                        titlebar=yes|no|1|0	是否显示标题栏。默认是 yes。
                        toolbar=yes|no|1|0	是否显示浏览器的工具栏。默认是 yes。

history对象：
    window.history  掌管的是，当前窗口(注意不是浏览器)历史记录，只要加载URL不一样就会产生新的历史记录

        属性:history.length 输出当前窗口历史纪律的条数

        方法:
            history.back()          返回上一条历史记录
            history.forward()       前进下一条历史纪律
            history.go()            
                参数： 
                    0           刷新当前页面
                    正整数      前进n条记录
                    负整数      后退n条记录   
                                
        location    地址栏
        方法：
            location.assign(url)        在当前窗口跳转到这个url
            location.replace(url)       在当前窗口替换成新的url 不会产生历史记录的
            location.reload()           刷新当前窗口
                        true            不经过浏览器缓存强制从服务器重载
        属性：

         url: 统一资源定位符
            格式：
                 协议://IP(域名)/:端口号/路径/?查询字符串#锚点

            location.protocol   协议    
                                file: 本地磁盘文件访问
                                http: 
                                https: (证书认证协议 )

            location.hostname   主机名  IP(在全球范围内找到你当前网络的地址)
                                        域名 就是 IP的别称

            location.port       端口号(默认隐藏的)
                                        注：是当前电脑中使用网络的软件，随机给他分配一个编号    0~65535

                                hostname:port   可以直接定位到当前使用网络的主程序
                                小细节：浏览器   默认端口号是8080
                                        http    80
                                        https   443

            location.pathname   路径

            location.search     查询字符串(前后端交互)  给服务器发一个数据进行查询的操作
                                ?name1=value1&name2=value2

            location.hash       锚点

                location        //              数据类型bojcet
                location.href   //              数据类型string


DOM     document.objcet model   文档对象模型
        例子：
        <div id="div1" title="hello" class="box1" style="width: 300px;  background-color: red;">div文本</div>

        节点类型:
                元素节点    <div>
                属性节点    id="div1"
                文本节点    div文本

        元素节点的获取：
                        documengt.getElementById(id)
                        功能:通过id获取符合条件的元素   (id必须是唯一的)
                        返回值:符合条件的一个节点

         //获取元素id

             var oDiv = document.getElementById("div1");

        //获取行间属性的值
            alert(oDiv.id);                     //显示div1
            alert(oDiv.title);                  //显示hello

        //注意：访问class属性间的值通过className访问
            alert(oDiv.className);              //显示box1

        //设置行间属性的值      打开控制台可以查看
            oDiv.id = "div2";
            oDiv.title = "world"
            oDiv.className = "box2"


        // 获取行间样式的值 只能访问内联的CSS样式
            alert(oDiv.style);          //显示  [object CSSStyleDeclaration]
            alert(oDiv.style.width);    //300
            alert(oDiv.style.height);   
            alert(oDiv.style.backgroundColor);  //如果CSS样式带-(横杠)，去掉-，从第二个单词开始首字母大写

        //修改行间样式的值
            oDiv.style.backgroundColor = "blue"

获取元素节点的方法：

        document.getElementById(id);

        document.getElementsByName(name属性的值)    
            功能：通过name属性的值获取符合元素的节点 只能全局查找，不能从局部查找，通常只有表单元素才有name
            返回值：伪数组/类数组      

        node.getElementsByTagName(标签名)           
            功能：可以从node节点开始，通过标签名获取符合条件的元素节点
            返回值：伪数组/类数组
                                                    
        node.getElementsByClassName(class名字)
            功能：可以从node节点开始，通过class名字获取符合条件的元素节点
            返回值：伪数组/类数组
            ie8一下不兼容

综合获取节点的方法
        document.querySelector()
            返回值：一个元素节点，找到符合条件的第一个元素节点
            参数：字符串 CSS选择器格式字符串
            ie8一下不兼容

        document.querySelectorAll()
            返回值：返回的是一个伪数组
            参数：字符串 CSS选择器格式字符串
            ie8一下不兼容

        CSS选择器格式字符串:https://www.runoob.com/cssref/css-selectors.html


常用节点分类：
                    节点类型     节点名字     节点值
                    nodeType    nodeName    nodeValue

        元素节点        1        标签名         null
        属性节点        2        属性名         属性值
        文本节点        3        #text         文本内容

        空格、回车、换行，看不见，是字符。

attribute和元素节点属性
获取属性节点的方法：
    格式：
        1.  node.attributes                         //获取这个节点上所有的属性节点集合对象
        2.  node.attributes.getNamedItem(" ")       //根据attributes属性节点集合获取其中某一个属性
        3.  node.attributes.[""]                    //简化

        4.  node.getAttributeNode("xx")             //获取节点上,某一个属性名为xx的节点  attribute = value
        5.   node.getAttribute(xx)                  //获取节点上,某一个属性名为xx的值    value   


        集合特点：      Map
            1.无序
            2.不重复
        
        例子：

            //获取其中的某一个属性节点  title = hello
            alert(oDiv.attributes.getNamedItem("title").nodeName);
            alert(oDiv.attributes.getNamedItem("title").nodeType);
            alert(oDiv.attributes.getNamedItem("title").nodeValue);

            //简化
            alert(oDiv.attributes["title"].nodeName);
            alert(oDiv.attributes["title"].nodeType);
            alert(oDiv.attributes["title"].nodeValue);




获取节点上属性节点的值、或者节点的属性值：
    setAttribute()
    getAttribute('xx')          //获取节点上,名字为xx属性的值         
    removeAttribute()           //删除属性节点
    nodeValue                   //通过node.nodeValue直接获取属性值  注意：节点必须是属性节点才合适
        区别于
                node.id
                node.title
                node.className

            1.class访问不用写 .className
            2.支持自定义属性

            oDiv.className = '';            //并不是真正的删除，只是把class值修改为空字符串
            oDiv.removeAttribute("title");  //直接带属性和值一块在样式中删除掉

例子：      <li class="current"></li>   
            通过liNode.className = ''       后把class属性改为<li class=""></li>   


getAttribute('xx')   和 node.getAttributeNode("xx")的不同是地方是：
        node.getAttribute('xx')         直接获取node节点的xx属性值     
        node.getAttributeNode("xx")     获取的是node节点上,属性名为xx的节点  
  

获取元素节点间标签内容的方法：

    节点.innerHTML              //获取标签间内容    会直接解析标签  只支持双标签 
    节点.innerText              //获取标签间纯文本  不会被解析      设置为纯文本   文本节点是通过元素节点的字节点获取
    节点.outerHTML              //从外标签开始到外标签结束之间的内容


获取元素节点子节点的方法
    1.下列这些属性都包含元素节点、文本节点、空格等文本节点：

        childNodes          访问当前节点下所有的子节点
        fristChild          访问子节点中的首位
        lastChild           访问子节点中的最后一位
        nextSibling         访问当前节点兄弟节点中的下一个节点
        previousSibling     访问当前节点兄弟节点中的上一个节点


    2.下列这些方法只获取子节点中的元素节点：
        
        children
        firstElementChild
        lastElementChild
        nextElementtSibling         
        previousElementSibling




DOM节点操作的方法
        parenNode父节点
                                                                                                                                                                                                                                                document.write()
            document.write()
                注意:会覆盖页面上的原有内容，并且标签会被解析
                

            createElement()          
                创建一个元素节点           
                格式:   document.creatElement(标签名)
                参数:   标签名
                返回值: 创建好的这个节点

            createTextNode()
                创建一个文本节点
                格式:   document.createTextNode(文本)
                功能：  创建文本节点(不管有没有标签创建出来的都是纯文本，标签不会被解析)    

            appendChild()
                将新节点追加到子节点列表末尾
                格式:   node1.parentNode.appendChild(node2)
                功能:   将node2节点插入到node1节点的子节点末尾

            insertBefore()
                将新节点插入在前面
                格式:   box1.parentNode.insertBefore(box2, box1)
                功能:   前缀是box1的父节点 来将 box2添加到box1前面

            replaceChild()
                将新节点替换掉旧节点
                格式:   box1.parentNode.replaceChile(box2, box1)
                功能:   前缀是box1的父节点 来将 box2替换掉box1

                div
                    p
                div

            removeChild()
                删除节点
                格式:   box.parentNode.removeChild(box)
                功能    前缀是box的父节点 来将 box节点从页面上删除       

            cloneNode()
                复制/克隆节点
                格式:   node.cloneNode()           克隆节点本身  
                格式:   node.cloneNode(true)       克隆节点本身和子节点

 this概念:  
     只要封装函数，任何一个函数系统都会内置一个叫做this的变量

        this的变量储存的是地址，是当前函数主人的地址

        注意：this永远指向当前函数的主人，函数的主人要通过当前上下文去判断
        this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，
        实际上this的最终指向的是那个调用它的对象

        追梦子讲的特别细致：    https://www.cnblogs.com/pssp/p/5216085.html

        //  常用情况：
        var person = {
            username: "钢铁侠",
            sex: "男",
            show: function () {
                alert(person.username);
                alert(this.username);
            }
        };
        // person.show();
        //给对象添加方法
        person.xx = function(){

        }


        //全局函数默认指向window
        function show() {
            alert(this);
        }

        /*  show();
         window.show(); */

        //指向0Btn
        window.onload = function () {
            var oBtn = document.getElementById("bnt1");
            oBtn.onclick = function () {
                alert(this);
            }
        }


offset系列获取外部样式方法：

        node.offsetWidth     width + border + padding  (眼睛能看到的实际宽度)
        node.offsetHeight    height + border + padding  (眼睛能看到的实际宽度)

offset系列通过定位获取位置的方法：

        node.offsetLeft      眼睛能看到的实际距离第一个有定位的父节点的距离
        node.offsetTop       眼睛能看到的实际距离第一个有定位的父节点的距离

数组和对象的遍历方法
    数组：
                for循环
                for...in快速遍历
                forEach

    例子：
        //for循环
    var arr = [10, 20, 30, 40, 50];
    for(var i = 0; i <arr.length; i++){
        document.write("for," + i + "," + arr[i]  +"</br>");
    }     

    //for...in快速遍历
    for(var i in arr) {
        document.write("forin," + i + "," + arr[i]  +"</br>");
    }  

    //forEach
    arr.forEach(function(item,index,arr){
        document.write("forEach," + index + "," + item  +"</br>");
    });

     //对象遍历
    var person = {
        username:"钢铁侠",
        aage:18,
        sex:"男"
    };

    for(var attr in obj) {
        //i     是当前遍历到的属性名字  obj[i] 是对象的值
        document.write("对象的遍历 " + i + "," + obj[i] + "</br>");
    }




绑定事件
                1.内联模式
                2.外联模式/脚本模式(最多)

            绑定事件模式：
                元素节点.on + 事件类型 = 匿名函数

                click       事件类型
                onclick     事件处理的函数


事件类型的种类：

        一、鼠标事件         可以绑定在任意的元素节点上 node 或者 document 
            click           单击
            dblclick        双击
            mousemove       鼠标移动（会不停的触发）
            mousedown       鼠标按下
            mouseup         鼠标抬起
            mouseover       鼠标移入（子节点也会触发相同的效果）注意：经过子节点会重复触发
            mouseout        鼠标移出（子节点也会触发相同的效果）注意：经过子节点会重复触发
            mouseenter      鼠标移入（子节点不会触发）注意：经过子节点不会重复触发        ie8以下才有
            mouseleave      鼠标移出（子节点不会触发）注意：经过子节点不会重复触发        ie8以下才有

        二、键盘事件         表单元素，全局window()
            keydown         键盘按下，如果按下不放手，会一直触发
            keyup           键盘抬起
            keypress        键盘按下，只支持字符键,即ait、tab、ctrl、上下左右箭头等都不支持  

        三、HTML事件
            1.window事件
                load        当页面加载完成以后会触发
                unload      当页面解构的时候触发(刷新页面、关闭当前页面) ie浏览器兼容
                scroll      页面滚动
                resize      窗口大小发生变化的时候触发
            2.表单事件
                blur        失去焦点
                focus       获取焦点
                select      当我们在输入框选中文本的时候触发
                change      当我们对输入框的文本进行修改并且失去焦点的时候
                submit      当我们点击submit上的按钮才能触发     注意：必须添加在form元素上
                reset       当我们点击reset上的按钮才能触发      注意：必须添加在form元素上


事件对象

        事件绑定：
            元素节点.no + 事件类型 = 匿名函数：
        【注】：系统会在事件绑定一旦完成的时候，生成一个事件对象

        【注】：在触发事件的时候，系统会自动去调用事件绑定的函数。将事件对象当作第一个参数传入。

    
    用形参显示事件对象，如果实参只有一两个的话，可以用形参来省略argunments IE8一下不兼容 只兼容window.event

    例子    
        window.onload = function () {
            var oBtn = document.getElementById("btn1");
            oBtn.onclick = function (ev) {
                // alert(ev);
                //[object MouseEvent] 如果实参只有一两个的话，可以用形参来省略argunments IE8一下不兼容 只兼容window.event
                var e = ev || window.event;   //事件对象的获取/固定写法
            }
        }

鼠标事件对象的属性

    事件对象：
                button的属性   
                    0   左键
                    1   滚轮
                    2   右键

                获取当前鼠标位置的属性：(原点位置不一样)

一、clientX、clientY    原点位置 可视窗口的左上角为原点，即使页面滚动了，还是当前窗口左上角位置与点击位置的距离 （点击除与当前body可视区域的x，y坐标）
二、pageX、pageY        原点位置 整个页面的左上角，包含滚出去的滚动距离,对于整个页面来说，包括了被卷去的body部分的长度
三、screenX、screenY    原点位置 电脑屏幕的坐上角，即把浏览器缩小后移动，还是以屏幕的左上点为坐标,点击位置距离当前电脑屏幕的x，y坐标             
四、offsetX、offsetY    相对于带有定位的父盒子的x，y坐标    （常用来确定点击点与被拖拽物体的相对距离）
五、x、y                和screenX、screenY一样


offsetLeft：    元素相对其有定位父级的左偏移量。没有定位父元素则定位body




鼠标事件对象属性修改键的属性：

     事件对象属性：

            e.shiftKey      按下shift键，为true,默认为false
            e.alkKey
            e.ctrlKey
            e.metaKey       windows系统，按下windows(开始)键，为true
                            macos系统，  按下commonand键，为true
            
            [注]:可以和彼得操作进行组合，形成一些快捷键操作


键盘事件对象的属性：

    键码
            e.keyCode     
            e.which
            返回值：键码返回的是大写字母的ASCII码值，不区分大小写
            格式 var which = e.which || e.keyCode
            [注]：只在keydown下支持 即键盘按下这个事件里是支持的

    字码值
            e.charCode    
            e.which
            返回值：键码返回的是大小写字母的ASCII码值，区分大小写
            格式：var which = e.which || e.charCode
            [注]：只在keypress  即键盘按下，只支持字符键,即ait、tab、ctrl、上下左右箭头等都不支持  


触发对象/目标对象和this:

        目标对象/触发对象  事件对象的属性  ie8一下不兼容 触发对象就是只指：这个事件是由谁而起的

        var target = e.target || window.event.srcElement;
    
        
        this 永远指向当前函数的主人 this是调用方法的对象，
        target evemt.target事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口.
        event.target和this不一样的

    例子：
         var oUl = document.getElementById("ul1");
            oUl.onclick = function(ev){
                var e = ev || window.event;
                var target = e.target || window/event.srcElement;
                alert(this.tagName);        //指向ul
                alert(target.innerHTML);    //显示li里面的内容，虽然事件对象添加的是ul，但是是因点击li而触发目标对象
            }

事件冒泡:
    嵌套节点，点击最里面节点，会从内向外逐级触发

            浏览器上事件天生的一个特点：事件流
            事件冒泡：由里向外逐级触发
            事件捕获：由外向里逐级触发

            阻止事件冒泡： 有浏览器兼容问题
            事件对象的属性和方法：
            cancelBubble=true       stopProagation()

阻止超链接的默认行为
                1.  简陋的阻止a链接默认行为的方式
                confirm() 弹出一个带确定和取消的提示框
                返回值：
                    如果点击确定，返回true
                    如果点击取消，返回false

                onclick = function () {
                return confirm("你确定要离开当前页面吗")}

                缺点：一旦运行到了return，后续的内容我们就执行不到了

                
                2.  规范的方法
                     var target = e.target || window/event.srcElement;

                 

拖拽：(拖拽三剑客)      伪代码、草稿
                mousedown            
                    记录鼠标按下的位置和被拖拽物体的相对距离（点击位置相对与body的距离-点击的物品与body的距离）
                    var offsetX = e.clientX - node.offsetLeft
                    var offsetY = e.clientY - node.offfsetTop

                mousemove   
                    一直保持，鼠标和拖拽内容的相对距离            
                    node.style.Left = e.clientX - offsetX
                    node.style.Top = e.clientY - offsetY

                mouseup              
                    取消拖拽


正则表达式，suoer string。
            正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），
            可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
                
                1、通过new去声明正则表达式
                    第一个参数：正则表达式的主体  字符串
                    第二个参数：修饰符
                        i忽略表达式（如：大小写）
                        g执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
                    【注】修饰符没有顺序

                2、省略new运算符去声明正则表达式

                3、通过常量赋值


正则表达式对象只有两个方法
            test
                格式：正则.test(字符串)
                功能：判断在字符串中匹配这个正则是否存在
                返回值：如果匹配成功返回true，匹配失败返回false。

            exec（了解  W3C）
                格式：正则.exec(字符串)
                功能：在字符串中匹配这个正则是否存在
                返回值：返回匹配到的串，匹配成功，返回一个装有字符串的数组,匹配失败，返回null
                注意：匹配返回第一支寻找到的值、后续不管


在字符串中使用正则的方法

    字符串的函数：
                match()
                    格式：字符串.match(正则)
                    功能：在字符串匹配是否有符合正则表达式，
                    返回值：匹配成功，返回装有匹配到子串的数组
                           匹配失败，返回null
                replace()
                    格式：字符串.replace(oldStr/正则, newStr);
                    功能：用newStr将oldStr替换，
                    返回值：替换成功的新字符串。
                split()
                    格式：字符串.split(分割符/正则);
                    功能：用分割符将原字符串进行分割
                    返回值：分割剩下的子串组成的数组。

                search()
                    格式：字符串.search(子串/正则)
                    功能：找到符合条件的子串第一次出现的位置
                    返回值：
                        如果找到，返回>=0的下标
                        否则，返回-1
                                    

正则表达式元字符：在正则表达式中有特殊含义的字符。

                单个数字和字符的元字符
                    .               匹配单个的任意字符
                    [范围]          匹配单个范围内的字符
                    [0-9]           匹配数字单个范围
                    [a-zA-Z0-9_]    判断、匹配单个的数字、字母下划线
                    [^范围]         判断、匹配任意一个除范围的任意字符
                    [^0-9]          判断、匹配任意一个非数字字符
                    \w              判断、匹配单个的数字、字母下划线  等价于 [a-zA-Z0-9_]
                    \W              判断、匹配单个非数字、字母下划线
                    \d              判断、匹配单个数字  等价于 [0-9]      
                    \D              判断、匹配单个非数字  等价于 [^0-9]
                    \n              代表换行


                空白字符
                    \s              匹配任意单个的空白字符  例如空格、静止字符 换行 回车 
                    \S              匹配任意单个非空白字符

                
                重复字符/限定符  x（任意的单个字符）
                    x?      匹配0个或者1个x     即0-1次 在有?的字符匹配的时候 有或者没有都可以，但不能有其他字符 
                    x+      匹配至少一个x字符   即>=1次
                    x*      匹配任意个x字符     即>=0次
                    x{m,n}  匹配至少m个，最多n个x字符，包括n
                    x{n}    必须匹配n个x字符
                    (xyz)   小括号括起来的部分是当做单个字符处理
                
                锚字符
                    ^  行首匹配  必须以这个正则开头
                    $  行尾匹配  必须以这个正则结尾


                替代字符  |     同时可以匹配多个字符 

                修饰符
                    i  忽略大小写
                    g  全局匹配
                    m  换行匹配
                    【注】如果在字符串，遇到换行，重新开始计算行首。
                    

                问题:在元字符中.代表任意字符
                解决:
                    转义字符：
                    \.  代表本来.字符的意思
                    \*  代表本来*字符的意思




综合运用：
    匹配中文字符的正则表达式：        [\u4e00-\u9fa5]
    代表纯中文                      /^[\u4e00-\u9fa5]+$/                
    /\w\.(zip|rar|gz)$/            是否为数字或者字母.zip | rar |gz 结尾的



本地存储技术:
                localStorage(IE8以下不兼容)HTML5才开始有该功能
                    1、永久存储、除非主动删除
                    2、最大可以存储5M   客户端的一个微型数据库
                    3、只能存储string
                    4、在浏览器隐私模式下是不支持的
                    5、本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，导致页面变卡
                    5、不能被爬虫抓取到

                cookie
                    1、可以设置过期时间、过期自动清除掉
                    2、最大可以存4KB
                    3、每一个域名下面最多可以存储50条数据

                sessionStorage（结合后台使用）


                

                localStorage 对象
                    setItem(name, value);   设置
                    getItem(name);          获取
                    removeItem(name);       删除

                
                注意：localStorage.setItem("name", "balue")     还可以简写为
                      localStorage.name = "value"
                      localStorage["name"] = "value"

认识this
    每一个函数中都有一个内置变量this,this指向当前函数的主人，函数的主人要根据上下文关系进行判断

常见的this，一般是下面三种情况
    1.全局函数
    function show(){
            alert(this)     //输出[object Window]指向window

    2.this指向对象
     var person = {
            username : "钢铁侠",
            show : function(){
                alert(person.username);
                alert(this.username);
                //this指向当前函数的主人，根据person.show(); 判断出show的主人是person对象  
            }
        }

    可以理解为：
     person.show = function(){       //本质上是给对象添加函数
            alert(person.username);
            alert(this.username);
        }

    3.this指向当前函数节点的主人 
    和情况2，本质上相似，oBtn.onclick是给:oBtn添加onclick函数,this指向当前函数的主人即oBtn节点
        window.onload = function(){
            var oBtn = document.getElementById("btn1");
            oBtn.onclick = function(){
                alert(this.innerHTML);

            }
        }




（改变this指向）强制数据类型转换的三种方法
    
    例子
                function show(x, y){
                            alert(this);
                            alert(x + "," + y);
                        }
                show(10,20);

    .call       在调用的是时候设置this指向，设置之后会直接自动调用      
                格式: 函数名.call("强制指向",原来的参数0,原来的参数1....);
                参数：
                    第一个参数：传入该函数this指向的对象，传入什么强制指向什么
                    第二个参数开始：将原函数的参数往后顺延一位

                show.call("call",20,40);


    .spply      在调用的是时候设置this指向，设置之后会直接自动调用    
                格式：函数名.apply();
                参数：
                    第一个参数：传入该函数this指向的对象，传入什么强制指向什么
                    第二个参数：数组    数组中放入我们原来的所以参数

                show.apply("apply",[20,40]);


    .bind       并不会直接执行，用来预设this指向
                格式： 函数名.bind("this指向")(参数)

                show.bind("bind")(40,50);

                //解析
                show.bind("bind");
                var res = show.bind("bind");
                alert(res)      //显示的是function () { [native code] }
                res(40,50);

                可以理解为：
                复制了一个同样的函数而且预设过this指向
例子

        function show() {alert(this)};
        
        window.onload = function () {
            var oBtn = document.getElementById("btn1");

            // oBtn.onclick = show;    
            //给obtn节点对象添加onclick属性:show的函数,this指向函数主人oBtn节点,点击按钮输出[object HTMLButtonElement]

            // oBtn.onclick = show.call("call");
            //这是错误的相当于把show的调用call方法的返回值hello给了oBtn.onclick,call在调用的时候，它会立即执行的，页面直接弹出
            

            //实例call的用法     写在一个函数内防止直接调用，而是点击按钮才会调用
            oBtn.onclick = function () {
                show.call("call");
            }

            //实际调用效果如下类似：
            oBtn.onclick = function show() {
                alert("call");
            }


            //实例apply的用法   写在一个函数内防止直接调用，而是点击按钮才会调用
            oBtn.onclick = function () {
                show.apply("apply");

            }

            //实例bind的用法用法    bind只是复制一个一样的函数并且预设bind为this指向，不会直接调用，所以不用再写在函数里面
            oBtn.onclick = show.bind("bind");

            //因为：它不会立即执行而且会复制并预设原来的函数，实际调用效果如下
            oBtn.onclick = function show() {
                alert("bind");
            }


        }

let关键字

    var 关键字声明变量          将变量或者形参所在函数的大括号作为作用域处理
    let 关键字声明变量          更过分，只要遇见大括号就形成作用域

            [注]：var关键字声明的变量，作用域叫做局部作用域
            [注]：let关键字声明的变量，作用域叫做块级作用域

    例子：
        if(1){
            var num = 10;
        }
        alert(num);         //可以调用显示因为if语句不是函数,这是一个全局变量

        if(1){
            let num = 10;
        }
        alert(num);         //不可以调用，因为let下只要有大括号就形成作用域


        var aBtns = document.getElementsByTagName("button");
            for (let i = 0; i < aBtns.length; i++) {
                aBtns[i].onclick = function () {
                    alert(i);
                }
            }

            //如果是var 相当于运行循环的时候没有作用到oncilck上,
            //仅仅通过循环添加3次点击事件，再在循环结束以后调用循环结果i=3

            //如果是let 每一次循环i的值都作用在onclick函数上,
            //因而每一个按钮都有不同的值，每一次调用的都是不同作用域下i的值


const关键字

    const   声明变量，变量值只能在声明的时候确定，后续是没有办法修改的
            [注]：  const声明常量(常量没有办法修改) 

    例子
        var IP =  "10.30.152.33";
        IP = "xx";
        alert(IP);      //显示xx


        //用const声明不可修改常量
        const IP =  "10.30.152.33";  //用const声明IP变量  
        alert(IP);                   //正常显示
        IP = "xx";                  
        alert(IP);                   //修改后，调用直接报错




箭头函数 =>
     箭头函数： 新潮的函数写法 =>
                [注]：适当的省略函数中的function和return关键字


    //与普通函数的区别
        function add(x){
            return x + 10;
        }

        var add = x => x + 10;


    //各种形式的箭头函数:
        
    //1.无参数、无返回值
    function show (){
        alert("hello world");
    }

    var show = () => {
        alert("hello world");
    }


    //2.有一个参数，无返回值
        function xxx(num){
            alert(num);
        }

        var xxx = num => {
            alert(num);
        }

    //3.多个参数，无返回值
        function show(x, y){
            alert(x + y);
        }

        var show = (x, y) =>{
            alert(x + y);
        }

        var show = (x, y) => (x + y);

    //4.有一个参数，有返回值的
        function add(x){
            return x + 10;
        }

        var add = x => x + 10;

    //5.有一个参数，有返回值的，中间有代码的
        function add(x){
            return x + 10;
        }

        var add = x => {
            //代码
            x + 10;
        }

        
        

箭头函数需要注意的部分
                1.箭头函数，不能用new调用
                2.箭头函数，如果返回值是一个对象的话一定要加小括号
                3.箭头函数中的this，指向的是上一层函数的主人
        

例子
    var newArr = arr.filter(function (item) {
            return item > 20;
        }) 

    箭头省略写法
    var newArr = arr.filter(item => item > 20);


    箭头函数，如果返回值是一个对象的话一定要加小括号
            function show(){
            return{
                username: "xx"
            }
        }

    箭头缩略写法防止被识别成函数的大括号，而不是return的的大括号，所以要在大括号外部加小括号
            var show = () => ({

        }); 







解构
    使用解构的好处：
                1.交换两个数
                2.函数可以返回多个值，打破了函数只能由一个return的规则
                3.函数定义参数，和传入参数的顺序改变,并且附加默认值(当没有传入参数的时候可以直接调用默认值)
                4.快速取出数组中的一个元素

            中括号解构      注重顺序        可以轻松调换两个参数的值
            大括号结构      不注重顺序      

    

    例子
        //原来写法
        var x = 10, y = 20, z = 30;

        //解构中括号写法
        var [x, y, z] = [10, 20, 30]

        //解构中括号写法
        var[x, [a, b], y ] = [10, [20], 40];
        alert(x + "," + y);     //10，40
        alert(a);               //20
        alert([a, b]);          //20,
        alert(b)                //undefined

        //解构大括号写法
        var {name, age, sex} = {
            age: 18,
            name: "钢铁侠",
            sex: "男"
        };

        //解构交换两个数
        var [x, y] = [10, 20];
        alert(x + "," + y);         10，20
        [x, y] = [y, x];
        alert(x + "," + y);         20，10



        //函数可以返回多个值，打破了函数只能由一个return的规则
        function show(){
            return ["结果1", "结果2", "结果3"];
        }

        var [a, b , c] = show();
        alert(a + "," + c);



        //函数定义参数，和传入参数的顺序改变,并且附加默认值(当没有传入参数的时候可以直接调用默认值)
        function showSelf(name, age, sex ){
            alert("我叫" + name + ",今年" + age + "岁,性别" + sex);
        }
        showSelf("男", 18, "钢铁侠"); 

        
        function showSelf({name, age, sex = "女"}){
            alert("我叫" + name + ",今年" + age + "岁,性别" + sex);
        }

        showSelf({
            age:18,
            sex:"男",
            name:"钢铁侠"
        });   


        //通过下标:name  arr获取值
        var arr = [10, 20, 30, 40, 50];
        var {0:a, 4:b} = arr;           
        alert(a);
        alert(b);
        alert(b === arr[4]);


ECMA6字符串
    传统字符串：所有单引号，双引号括起来的都叫做字符串
            ECMA6字符串：反引号 ``  (它位于左上角，数字1键的左边、Esc键的下方。在英文输入法下，直接按这个键)

                1.ECMA6字符串，想怎么写就怎么写，换行，代码缩进，都能在字符串中体现出来
                2.${变量/表达式/函数调用}
                3.省略+号


    例子    （与解构相结合使用）
    
        function showSelf({name, age, sex = "女"}){
            // alert("我叫" + name + ",今年" + age + "岁,性别" + sex);  传统写法

            alert(`我叫${name},今年${Math.max(age, 20 , 30)}岁,是一位${sex}性`);
        }

        showSelf({
            age:18,
            sex:"男",
            name:"钢铁侠"
        });




ECMA6新增数组方法

    Array.from()    将伪数组转换成真数组

    例子
        var aLis = document.getElementsByTagName("li");
            alert(aLis.length);         //像通过document.getElement获取的节点数组都是伪数组
            aLis.push("hello");         //报错本质aLis还是一个对象，它不是一个数组  

            aLis = Array.from(aLis);    //将伪数组转换成真数组
            aLis.push("hello");
            alert(aLis);


ECMA6新增数组查找方法
    find()

            功能：  在数组中查找符合条件的元素，只要找到第一个符合条件的元素，就终止遍历
            返回值：找到的元素

    findIndex()
            返回值：找到的元素的下标


    例子
    var arr = [10, 20, 30, 40, 50];
        //传统查找
        var res = arr.find(function(item, index, arr){
             //查找条件
             return item > 20;
         });
         alert(res);

        //ECMA6
        alert(arr.find(item => item > 20) );
        alert(arr.findIndex(item => item > 20));

    arr.copyWithin
            第一个参数：从那个下标开始
            第二个第三个参数坐标的范围：范围（start,end）不取end，即end-1
            ES6为Array增加了copyWithin函数，用于操作当前数组自身，用来把某些个位置的元素复制并覆盖到其他位置上去。

    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        arr.copyWithin(2, 4, 9);
        alert(arr);     //1, 2, 5, 6, 7, 8, 9, 8, 9, 10



 Object.assign   合并对象（浅拷贝）
                [注]：将所有传入的对象，合并到第一个对象中

            浅拷贝：只拷贝地址
            深拷贝：将复合数据类型重新生成一份，进行拷贝

            Object.assign(obj1,obj2,obj3);


集合的概念
    集合：
            1.不重复
            2.无序


            Set                     
                格式：
                let set = new Set();
                添加值
                    set.add()  


            Map                     
                格式：
                let map = new Map();
                添加值
                    map.set()  



Set方法声明集合
    
    let set = new Set()             //声明集合
    set.add                         //给集合添加元素

集合遍历
            
        for...of 集合遍历

        let set = new Set()  

        1.通过key(键)遍历
        for(let item of set.keys()){
            console.log(item);
        }

        2.通过value（值）遍历
       for(let item of set.values()){
            console.log(item);
        } 
        
        3.通过entries（键的值）遍历
        for(let item of set.entries()){
            console.log(item);
        }

        通过entries（键和值对应）遍历集合可以总结出：必须键和值一样，并且不能存函数的对象，这种数据解构叫做Set集合



根据集合不重复的特点，把数组声明成集合就可以去重复，
//数组变集合
        var set = new Set([10,20,30,40,50,40,30,20,10]);

//集合变数组
        var arr = [...set];

//简化数组变集合后，集合变数组去重
var arr = [10,20,30,40,50,40,30,20,10];
arr = [...new Set(arr)];


Map 映射方法声明集合

    let map = new Map();                 //声明集合
    map.set("键", "值");                 //添加数值
    map.get("键")                       //通过get键key获取值value


    例子：
    let map = new Map();
    map.set("张三", "打渔的");
    map.set("李四", "种地的");
    map.set("王五", "挖煤的");
    map.set("李四", "打猎的");
    alert(map.get("王五"));             //显示挖煤的


//map遍历   通过for...of

        for (let [key,value] of map){
            console.log(key,value);
        }



总结遍历
            数组
                    for循环                                     通过元素下标遍历
                    for...in    for(var i in arr){}             快速遍历
                    foreach     arr.forEach(function(item, index, arr){});  通过元素和下标遍历
                    for...of    for(var item of arr){}                      通过元素遍历，没有下标



            对象    通过对象的属性attr进行遍历,通过attr获取对象属性，object.[attr]获取对象的值                                
                    for...in    for(var attr in object){}   
                    
                                                                                        

            集合
            Set     for...of     for(let item of set.keys/values/entries()){}
            Map     for...of     for (let [key,value] of map){}


例子
        var arr = [10, 20, 30, 40, 50];
        for (i = 0; i < arr.length; i++) {
            document.write("for循环： " + arr[i] + " 下标： " + i + "</br>");
        }

        
        for(var i in arr){
            document.write("for...in遍历： " + arr[i] + " 下标： " + i + "</br>");
        }

        arr.forEach(function(item,index){
            document.write("forEach遍历： " +item + " 下标： " + index + "</br>");
        });

        //通过for...of遍历数组
        for (var item of arr){
            //item是当前遍历到的元素,他是根据元素进行遍历的，没有下标
            document.write("for...of遍历： " + item + "</br>");
        }


        
        var person = {
            username: "钢铁侠",
            age: 20,
            sex: "男"
        };

        for(var attr in person){
            //attr  遍历到的对象的属性
            document.write("for...in对象遍历： " + attr + " " + person[attr] + "</br>");
        }


构造函数
    例子1：

        function person (){//普通函数}
        var per = person();
        alert(per);                     //  undefined


        function Person (){//构造函数}
        var per1 = new Person();    
        alert(per1);                   //   [object Object] 

    例子2： 
        var p1 = new Person("blue","男");
        function Person(name, sex) {
            //1.原料
            // this = new Object();     构造函数自动完成，不用写出来

            //2.
            this.name = name;
            this.sex = sex;
            this.showName = function () {
                alert("我的名字叫" + this.name);
            }
            this.showSex = function () {
                alert("我的性别是" + this.sex);
            }

            //3.出厂
            // return this          构造函数自动完成不用写出来
        }
    
    

    1、构造函数也是一个普通函数，创建方式和普通函数一样，但构造函数习惯上首字母大写
    2、构造函数和普通函数的区别在于：调用方式不一样。作用也不一样（构造函数用来新建实例对象）
    3、调用方式不一样。
        a. 普通函数的调用方式：直接调用函数名（）                person();
        b. 构造函数的调用方式：需要使用new关键字来调用函数名（）  new Person();
    4、构造函数的函数名与类名相同：Person( ) 这个构造函数，Person 既是函数名，也是这个对象的类名
    5、内部用this 来构造属性和方法 
    5、构造函数的执行流程
        A、立刻在堆内存中创建一个新的对象
        B、将新建的对象设置为函数中的this
        C、逐个执行函数中的代码
        D、将新建的对象作为返回值
    6、普通函数例子：因为没有返回值，所以为undefined
    7.用instanceof 可以检查一个对象是否是一个类的实例，是则返回true；
      所有对象都是Object对象的后代，所以任何对象和Object做instanceof都会返回true



prototype   原型对象
            概念：每一个函数上，都有一个和原型对象prototype


            用在构造函数上，我们可以给构造函数的原型prototype，添加方法
            1.如果我们将方法添加到构造函数的原型prototype对象上
            2.构造函数构造出来的对象共享原型上所有的方法


构造函数构造出来的对象，有一个属性 __proto__ 指向构造出来这个对象的构造函数的原型
        

instanceof  关键字
功能:        判断某一个对象是否是这个构造函数构造出来的