Day 01  基本语法
常常记住的单词
    attributes  属性    HTML标签上的特性，它的值只能够是字符串。         指定是html的属性
    properties  属性    DOM中的属性，是JavaScript里的对象；     复数    指定是DOM的属性
    property    属性                                          单数
    value       值
    element     元素
    define      定于
    undefined   未定义
    create      创建
    able        能够
    writ        写
    Sibling     兄弟
    bing        绑定
    call        呼叫
    apply       应用
    use         使用
    user        用户
    info        信息
    file        文件    
    login       登录
    register    注册    
    config      配置
    static      app.use(express.static(__dirname + '/xxx')) 暴露静态资源
    status      response.status(code)	 设置响应状态码
    state       xhr.state 设置状态  xhr = new XMLHttpRequest xhr.onreadystatechange = function{if(xhr.readyState === 4 && xhr.status === 200){console.log('成功')}}
    
                                                             
                例子  arr  = [1,2,3,4,5]       arr.reduce((L , i )=> L + i,0)     结果为15
    reduce      根据数组中元素进行统计处理  arr.reduce( (累计值,当期值 )=> 累计值 + 当期值,  开始时预定累计值  )
    render      用来渲染组件标签的回调函数,index.js汇总vue组件,调用render函数得到他返回的组件标签函数render:h =>h(App)
    random      随机数    Map.random
    radio       单选框
    radius      给标签添加圆角

    注意：
        当在编写HTML源代码时，我们可以在HTML元素上定义属性。一旦浏览器解析此代码，
        将创建一个HTMLInputElement对象，该对象将包含数十个属性，
        如：childElementCount，childNodes，children，classList，className， clientHeight 等
        此时说的这些对象属性即为properties。而我们在HTML标签上定义的属性，则为attributes。

    1、./是当前目录
    2、../是父级目录
    3、/是根目录


一、Javascript简介
        1.javascript是什么

        美国 布莱登·艾奇 1995年 10天开发出来的
        javescript 是一门动态的、弱类型、解释型的脚本语言
        动态：是由在执行的时候,才能确定数据类型
        弱类型：变量数据的类型不是确定的,可以随意进行改变；
        解释型：相对编译型来说,编译型计算机在执行之前需要把程序进行编译,完事之后才执行
                解释型,不需要编译,执行的时候,一行一行去解释执行


        脚本：一般只要是脚本语言,都代表可以嵌在其它的语言当中进行执行；

        起初叫什么  后来怎么叫做javascript
                    livescript  sun 开发了java      借助java的名字火了一把
                    把livescript 改为了 javascript
                    java和JavaScript    不是一回事

        2.为什么要有javascript
            开始能干啥  
                        仅仅是负责表单验证,如果没有JS,那么我们网页的表单需要通过网络传送去服务器进行验证
                        占用宽带资源太严重,并且用户体验并不好
            现在能干啥
                        表单验证
                        用户交互
                        游戏
                        后端开发

        3.javascript的组成部分
            ECMAscript      负责JS的语法
            DOM             全称（document object model） 文档对象模型（操作元素）
            BOM             全称（browser object model）  浏览器对象模型（操作浏览器）

        4.js的体验,第一个js程序,JS的语句特点
            alert函数
            console.loge            以日志的形式在控制台输出内容
            document.write          把内容作为页面内容进行展示
            console.dir

        5.js的三种书写位置及优缺点
            内嵌式      用的比较多,一般写项目初期都会使用内嵌,最后变为外链
            外链式      里面不能写其他代码,外链后几乎都是外链
            行内式      局限性比较大,只能对事件进行书写JS,问题也很大,做不到解构和行为分离

二、变量的作用
        什么是变量,什么是常量
            变量：可以变化的量
            常量：不可以变化的量
        为什么要有变量
            什么是程序？ 什么是进程
            程序：代码的集合,一般指的是文件,程序是静态的
            进程：运行的程序,就被称作进程,进程是动态的

            程序其实就是一个输入 运算 输出的过程
            那么我们要对一个数据进行运算,然后进行输出,这个数据就需要一个东西去保存
            这个东西就是我们所说的变量,本质上就是一个容器（内存空间）;

        1、定义变量
            定义变量使用var关键字,先定义后使用,定义好之后,可以给变量赋值（存值）
                var age = 1;        //变量初始化,定义变量的同时给变量赋值

            定义变量不使用var,那么变量必须要赋值,不赋值报错未定义undefined
                var age;            //定义了一个变量
                age = 1;            //先定义完然后给这个变量赋值    

        2、变量的命名和规范（组成,）
                变量的命名：数字    字母    下划线_     $
                不能以数字数字开头,不能和关键字以及保留字同名,变量名需要见名思意

            大驼峰          var ClassNumber
            小驼峰          var classNumber     前端人员最常用的是这个,只有特定情况使用大驼峰
            下划线          var class_number

        3、关键字和保留字
            javascript的关键字:
            break   case      catch   continue    default   delete      do
            else    finally     for   function    if   in   instanceof     
            new     return    switch  this         try      typeof
            var     void      while   with

            javascript的保留字:
            abstract    boolean     tyte    char    class   const   debugger    double
            enum        export      extends         final   float   goto        implements
            import      int         interface       long    native  package     private
            protected   public      short           static  super   synchronized
            throws      transient   volatile


            abstract        delete      goto            null            throws  
            as              do          if              package         transient  
            boolean         double      implements      private         true  
            break           else        import          protected       try  
            byte            enum        in              public          typeof  
            case            export      instanceof      return          use  
            catch           extends     int             short           var  
            char            false       interface       static          void  
            class           final       is              super           volatile  
            continue        finally     long            switch          while  
            const           float       namespace       synchronized    with  
            debugger        for         native          this      
            default         function    new             throw

    常量理解
        用来保存数据，保存的数据不instanceof占用空间，保存在内存的栈结构分区中
        常量声明必须时大写      例子：var PERSON = 'kebo';
    
三、数据类型
    1、数据类型（存储的数据的类型）
        基本数据类型（也可以叫值类型）
            number  string  boolean undefined   null  Symbol
        对象数据类型（也可以叫引用数据类型、复杂数据类型）
            object  Array   function


        typeof能够识别      string number boolean function object undefined symbol
        instanceof能够识别  Array
        === 专门用来识别    null
        
        

    2、基本使用场景
        number    整数    小数    科学计数法  2进制（0b） 8进制(0）   16进制(0x)  NAN也是number数据类型(number包含数字、和不是数字两种 NaN为不是数字)
        string    单引号,双引号,空字符串,空白字符串
        undefined 定义的变量没有赋值        定义了没有赋值 var a;
        null      定义的变量赋值为空对象  数据类型一定是object（一般是对象进行初始化使用 或者产出一个对象的时候用到）



        //变量初始化的约定俗成的使用方法
        var sum = 0;         //初始化,初始给变量的值,但是此时并不知道后面要存储的值,代表以后存储的数字
        var canName = '';    //代表以后存储的是一个字符串
        var isClose = true;  //代表以后要存储的是一个boolean
        var dog = null;      //代表这个dog变量以后要存储一个狗的对象；
        var a = undefined;   //这个情况几乎不存在,以为初始化就是对一变量进行初始赋值,
                             // undefined本来就是定义变量,没有赋值,所以不能叫做初始化

四、运算符和表达式
    运算符：参与运算的符号
    表达式：由变量或常量和运算符组成的式子, 表达式是有值的

    1、算术运算符和表达式
        + - * / % ++ --
        %取余的作用：
            1、可以拿到余数
            2、可以拿到一个范围  
            例如任何一个数对78取余,余数永远在0~77之间      

        var a = 7;
        //a++ 先赋值（先把a的值赋值给表达式） 后++（后让a的值+1）
        //++a在前 先++（先让a的值+1） 后赋值（后把a的值赋值给表达式）
        // console.log(a++);   //7
        // console.log(a);     //8

        console.log(++a);       //8
        console.log(a);         //8  

Day 02 运算符和表达式
    2、赋值

        把 = 右边的值 赋值给 = 左边的值         （=左边一定是变量）

        += -= *= /= %=  复合赋值运算符

    3、比较（条件运算符）和 表达式
        >   <   >=  <=  ==  !=   ===   !==

        !=  比较时，若类型不同，会偿试转换类型；

        !== 只有相同类型才会比较。


    4、逻辑运算符   通常用在多个表达式的连接
            &&      ||      ！
            与      或      非(！无论放在什么东西之前,最后的结果都是boolean)

    &&  如果用在两个值之间,本质上就是一个过程
            先判断&&之前是否为真,如果为真,那么就取后面的值,赋值给逻辑表达式
            如果前面为假,那么就取前面的值,赋值给逻辑表达式

    ||  
            先判断||之前是否为真,如果为真,那么就取前面的值,赋值给逻辑表达式
            如果前面为假,那么就取后面的值,赋值给逻辑表达式

    

    5、三元运算符       三目表达式

        a > 0 ? 10 : 100;
        先执行第一个表达式是否为真（？前面的表达式）  
        如果第一个表达式值为真,那么把冒号前面的值,赋值给整个表达式
        如果第一个表达式值为假,那么把冒号后面的值,赋值给整个表达式

二、数据类型转换
    1、数据类型强制转换
        Number      强制将一个其他数据类型转化成数字类型,转不了就是NaN
                    通常情况下是用来转字符串的
                        如果字符串整体是一个数字,那么就转换成这个数字
                        如果字符串整体来看不是一个数字,那么就转化成NaN
                        如果字符串是一个特殊的空字符串或者空白字符串,那么转化成0
                    
                    转化布尔值Boolean    true会转化为1              false会转化为0
                    转化undefined       undefined会转化为NaN
                    转化null            null会转化为0
                    
        String      强制将一个其他数据类型转化成字符串
                    转化字符串没有什么特殊,只要给我东西,那么就会把这个东西原样变为字符串输出

        Boolean     强制将一个其他数据类型转化成boolean类型
                    转化数字的时候,除了0是false,其余都是true
                    转化字符串的时候,除了空字符串是false,其余都是true
                    转化undefined、null、NaN都是false
                    总结:非空即真 非零即真
    2、数据类型隐式转换
        各种类型在适当的场合会发生隐式类型
        主要是运算和条件判断过程中  
            例如 
                var a = 5;
                var b = a + 5;

                var a = 5;
                var b = a + false;

    3、数据类型手动转换（其实就是字符串当中提取数字）
        parseInt()          //从字符串中提取整数（必须数字开头否则NaN）
        parseFloat()        //从字符串中提取小数（必须数字开头否则NaN） 
        **                  //表示次方 2**3表示 2的3次方 a**b表示a的b次方

三、基本数据运算（表达式的值）
    1、同种数据类型运算和比较
        数字和数字
            小数运算的时候不准
            数字能表示的最大值
            1/0                 0/1              0/0     结果分别是：  
            infinity无穷大       0                NaN 


        字符串和字符串      字符串有数字型的字符串和不是数字型的,还有空白字符串
            +              字符串拼接
            -              双方如果不能转化成数字就是NaN
            *              双方如果不能转化成数字就是NaN
            /              双方如果不能转化成数字就是NaN
            比较           比较Unicode值

        boolean和boolean
            +               
            -
            *
            /                1/0=infinity                 0/1=0              0/0=NaN  
            比较

        undefined和undefined
            +          NaN
            -          NaN
            *          NaN
            /          NaN
            比较      undefined == undefined    true  
    
    2、不同数据类型运算和比较   字符串有数字型的字符串和不是数字型的
      
        数字和字符串            + - * / 比较        数字和数字 或者数字和NaN
        数字和boolean          + - * / 比较         boolean转0 1
        数字和undefined        + - * / 比较         undefined转化成NaN
        数字和null             + - * / 比较         数字和0比较运算  但是0不等于null

        字符串和boolean        + - * / 比较         如果是+拼接字符串 如果-*/ 字符串转数字或者NaN boolean转0 1
        字符串和undefined      + - * / 比较         如果是+拼接字符串 如果-*/ 字符串转数字或者NaN undefined转NaN
        字符串和null           + - * / 比较         如果是+拼接字符串 如果-*/ 字符串转数字或者NaN null转0

        boolean和undefined    + - * / 比较         undefined转NaN,所以+-*/都是NaN  比较大小,都是false
        boolean和null         + - * / 比较         boolean转0和1  null转0  但是false不等于null

        undefined和null       + - * / 比较         undefined转NaN,所以+-*/都是NaN   undefined=null

总结：
        console.log(Number(null));              //0
        console.log(Number(undefined));         //NaN
        console.log(Number(NaN));               //NaN
        console.log(Number(false));

        console.log(Boolean(null));             //false
        console.log(Boolean(undefined));        //false
        console.log(Boolean(NaN));              //false

        console.log(undefined == null);         //true
        console.log(undefined == NaN);          //false
        console.log(null == 0);                 //false
        console.log(NaN == 0);                  //false
        console.log(NaN == NaN);                //false

        console.log(false == null);             //false
        console.log(false == undefined);        //false
        console.log(false == NaN);              //false


特殊情况：
    
        undefined   和null     ==相等,===不相等因为数据类型不同   undefined转数字是NaN, null转数字是0  
        undefined   和NaN      不相等     虽然双方被Number()NaN，  
        0           和null     不相等     虽然双方被Number()都是0,但是null是表示对象的,与表示基本数据类型的0是不相等的
        false       和null     不相等     虽然双方被Number()都是0   
        NaN         和null     不相等     虽然undefined被Number()是NaN  
        空字符串''   和null     不相等     虽然双方都是0
        NaN         和NaN      不相等
        

       
    

    在其余的情况下,只要是不同的基本数据类型进行运算和比较
        第一步：先看是不是+,如果是+看看由没有字符串,如果有,就是字符串
        第二部：再看看是不是比较,如果是比较,看是不是两边都是字符串,如果是字符串比较Unicode
        最后：全部转数字


数值扩展：
    1. 二进制与八进制数值的表示方法： 二进制0b, 八进制0o
    2. Number.isFinte(i)        判断是否是有限大的数
    3. Number.isNaN(i)          判断是否是NaN
    2. Number.isTnteger(i)      判断是否是整数
    2. Number.parseInt(i)     将字符串转化为对应的数值
    6. Math.trunc(i)            直接去除小数的部分


Day03   流程控制语句：顺序语句    分支语句    循环语句
        

一、if判断
    单分支
    if(一般都是一个表达式,但是最终只要有值就行,并且这个值最终会转化为boolean){
        判断条件值为true的话就执行这里
    }

    双分支(三元表达式)
    
        单分支和双分支其实都可以理解是多分支,也就是把一件事分成两种情况去处理,符合条件的和不符合条件的
        单分支只是处理了符合条件的,不符合条件的不管
        多分枝都要处理

    if(一般都是一个表达式,但是最终只要有值就行,并且这个值最终会转化为boolean){
        判断条件值为true的话就执行这里代码块
    }else{
        否则执行这里的代码块
    }
    
    多分枝
        多分枝是把一件事情分成多种情况去考虑,每一种情况都要去处理

        if() {

        } else if() {

        } else if() {
        
        } else{
            
        }


三、 switch....case

    语法：
        switch(有值的东西,最后这里面是一个值,一般不会进行转化){
            case 值:            //case代表的是标号,它不是我们的代码语句,只是用来左对比的
                    代码块;     //如过switch括号里的值和case的值相对,就执行这里的代码,注意switch里面的判断是严格模式 ===
                    break;
            case 值:
                    代码块;
                    break;
            case 值:
                    代码块;
                    break;
            default:
                    代码块;
                    break;
        }                                                             

四、 for循环
        1.循环的意义
            for(一般初化表达式;一般都是条件表达式;自增自减){
                循环体(代码块)
            }

            执行过程:       
                    第一次循环：
                        首先执行初始化表达式
                        接着执行条件表达式
                        然后再去执行循环体
                        最后执行自增自减表达式
                    
                    后续循环
                        执行条件表达式
                        执行循环体
                        最后执行自增自减表达式
            
            一定注意：
                for循环初始表达式只是在第一次循环的时候执行,后续循环全部都不执行了
                for循环中循环的变量i有两个作用：1、控制着循环的次数 2、变量同时也是有值的


五、 while循环     先判断后执行,只有条件为真才会执行循环
 while(判断条件){
     执行语句
 }


六、 do...while循环      先执行后判断 所以即使判断条件不成立,也会先执行一次,再判断
do{执行语句}(
    
)while(判断条件)


    continue;   //结束当前循环(continue以下的代码不会执行,从下一次开始继续),跳出当前循环,直接进行下一次循环
    break;      //再循环当中,跳出离他最近的那一层循环,如果是多层循环,要注意


7、数组
    数组的概念,作用,定义
    数组：是一个具有相同类型或者不同类型的数据有序集合

    为什么：因为我们想要一次性拿到很多个数据,如果没有数组,就得定义很多的变量去储存

    arr.length
        只要定义一个数组,数组里面就会有一个默认的属性叫做length,它代表着数组的长度
    arr.index
        索引,也被称作下标,通常情况下只要我们知道了索引,就可以拿到这个数组对应的这个索引的值


    数组的不同位置  增  删  改  查

    在数组的末尾添加一个数组  直接arr[arr.length] = 添加的数字
    在数组的头部添加一个数组  for (var i = arr.length - 1; i >= 0; i--) {arr[i + 1] = arr[i];} arr.[0] = 添加的数字   
    在数组的中间添加一个数组

    在数组的末尾删除一个数组   arr.length--
    在数组的头部删除一个数组   for(var i = 1; i<arr.length; i++){var arr[i-1] = arr[i]}  arr.length--
    在数组的中间删除一个数组

    反转数组且不用新数组     无论数据是否是单双数,根据对称原则反转,如果是单数则中间数组不用动,连边对称转换,如果是双数则刚好
    for (var i = 0; i < arr.length / 2; i++) {
        var temp = arr[i];
        arr[i] = arr[arr.length - 1 - i];
        arr[arr.length - 1 - i] = temp;
    }

    截取数组生成新的数组    newArr[newArr.length] = arr[i];

Day05 函数
一、函数的基本使用

    什么是函数：
        具有某种特定功能的代码块
    为什么要有函数：
        1.函数可以解决代码复用的问题
        2.函数可以把整个项目模块化
    函数的定义：
        函数定义或者调用都要考虑函数的三要素：功能、参数、返回值 

        功能：
            一般说的就是函数能做什么,通常情况下函数名就代表着函数的功能
        参数：
            函数的小括号当中,写的是参数,函数定义的参数,我们称为形参（形式参数）
            形参写出来就相当于在函数内部var了一个变量
            函数调用的时候,小括号里面写的也是参数,这些参数我们称为实参（实际参数）
            函数调用的实参本质上就是给函数定义的形参进行赋值
            
        返回值：
            每一个函数都会有返回值,有点函数的反沪指比较明确,写了return
            但是有的函数没有声明return,并不代表这个函数没有返回值,而是省略了return,实际上返回值是undefined
            函数调用也被称作函数调用表达式,既然函数调用是一个表达式,那么函数调用时有值,返回值就是函数调用表达式的值
    

二、函数的分类
    1）        无参数无返回值   
    2）        无参数有返回值
    3）        有参数无返回值
    4）        有参数有返回值
    5）

    return 只能输出一个值,想要输出多个值可以使用数组[]

    例如：
        return [max, min];  正确
        return  max, min;   错误

    函数的两种写方法
        function f1(){}             函数声明    字面量定义
        var f1 = function(){}       函数表达式  定义函数

        
    
    函数传参,分为基本数据类型和对象数据类型

    传基本数据类型和对象类型不一样,基本数据类型传进去以后,函数外和函数内操作的不是一个值；
    所以当传递基本数据类型的时候,函数内部运算后的结果我们需要返回。

    但是如果传的是对象类型（数组）,那么函数内部和外部操作的是同一个数据(数组),因此函数内部
    对数组所有的操作就相当于和外部操作一样,所以运算完之后就不需要返回,外部一样能看到发生了变化。





四、作用域
    1）     作用域概念说的是：变量作用的区域或者范围
            作用域的作用：变量在各自的作用域当中起作用
            
    2）     局部变量：在局部作用域当中起作用的变量（函数当中定义的变量）
            全局变量：在全局作用域当中起作用的变量（函数外部定义的变量）

            注意：
            形参相当于在函数内部用var声明局部变量    //var 形参 = 实参;  
            在函数内部声明的变量如果没有var,或者省略var,那么不调用函数的时候,这个变量是局部变量,如果调用函数
            这个变量是全局变量,这是一种错误的写法,不推荐使用

            函数内不写var声明的就是全局作用域下的内容：但是只有在调用函数的时候才会形成
            例1
            var add = function () {
                b = 20;
            }       
            alert(b);       //不可以直接调用,但是先调用函数add()之后,就可以调用到 b=10;

            例2：
            var add = function () {
                acc = function(){
                    b = 20;
                }
            }  
            add();
            acc(); //不可以直接调用,要在add()函数调用的同时调用acc()函数,就可以调用到 b=10;,acc也可以写在add内部

           
            例3：
            var add = function () {
               var acc = function(){
                    b = 20;
                }
                acc();
            }  
            add();
            //如果是var acc = function(){b = 20};, acc在add函数的局部作用域内,就必须在add函数内部调用acc
        



    3）     作用域分类（全局、局部、块级）

    在es5单中,没有块作用域,只有全局和局部

    全局作用域和局部作用域当中定义变量的坑：
        当我们定义变量的时候,都会加一个var,但是也有不加var的情况;
        如果是全局变量：没有定义过的变量,不加var,那么必须给这个变量赋值,而且相当于给这个变量加var,是一个地地道道的全局变量
        如果在局部：没有定于过的变量(没有参数是它,也没有加var),定义这个变量不加var,首先要看外部全局是否定义过变量,如果全
    局定义过,那么这个变量就不是在初始化,而是在操作全局变量。如果没有定义过,相当于在全局加var定义这个变量。

    4）     作用域链：说的是变量在查找的过程：变量在查找的时候,首先从自己的作用域当中去查找,如果没有,往上一级作用域当中
    去查找,一直查,直到函数外部的全局作用域,只要找到,立刻停止往上查找,直接输出。如果没有找到会一直往上查,如果最后查到
    函数外部的全局都没有,报错。


函数执行过程：

        栈解构：先进后出            放变量
        堆解构：随意增删            放对象

        程序执行开始：首先肯定是创建全局环境,然后才是局部环境,并且这些环境都是在栈里进行管理的
        创建完全局环境之后,会把程序当中所有的全局变量收集起来并且进行执行开辟空间。

        接着函数调用的时候才会创建函数环境,并且收集所有的局部变量,执行开辟空间

        当函数执行完成以后,也就是函数返回值之后,代表函数执行完成。此时,函数的环境会立马从栈中弹出,
        代表函数环境被销毁,也就是释放内存。

        当整个环境结束以后,全局环境最后才会弹出栈,也就是销毁了全局环境,释放全局环境占用的内存。


第五节：预解析  预解释 提升变量 声明变量
    1） 预解析
            变量    带var和不带var：预解析只会解析带var的,如果不带var,不进行预解析

            函数    字面量和表达式函数关系
                    function f1(){1}          如果是这种写法,函数整体会提升
                    var f1 = function(){2}    如果是这种写法,只会提升var f1,不会提升函数的表达式function(){}  

                    函数名一样，会优先提升1，后面提升2

    2） 与解析效果
            全局    全局当中所有带var的变量,以及使用字面量定义的函数   都要提升到全局的最上方

            函数    函数当中所有带var的变量,以及使用字面量定义的函数,都要提升到这个函数的局部环境的最上方
                    注意：带var的变量会提升,但是变量后面的fun(){}函数不会提升

    例子：
        alert(a);                   //undefined
        var a = 0;
        alert(a);                   //0
        function fn(){
            alert(a);               //undefined
            var a = 1;              
            alert(a);               //1
        }
        fn()
        alert(a);                   //0

        解析为
        var a;
        function fn(){
            alert(a);              
            var a = 1;              
            alert(a);              
        }
        alert(a);                   
        a = 0;
        alert(a);                  
        fn()
        alert(a);    


第六节 IIFE 函数作为参数 & arguments

    IIFE    Immediately Invokel Function Experssion,译为：立即调用函数的表达式（匿名函数自调用）

    var f1 = function(){ };     // =号右边的就是匿名函数

     (function(){               //匿名函数自调用

     })();

    匿名函数自调用的特点
        这样的写法就是匿名函数自调用,匿名函数自调用的特点,定义的时候就一起调用了,不会发生预解析
        匿名函数自调用只能执行一次,通常用来做一些项目的初始化
    匿名函数自调用可以做那些事
        第一：封装代码实现,不把代码暴漏出去
        第二：可以防止外部的命名空间被污染


函数实参伪数组    arguments   字面意思 函数传递的实参伪数组形式,可以调用、查看函数实际传递的参数
    例子：
        var a = 10;
        var b = 5;
        function add(a,b){
            console.log(arguments);     
        }
        add(a, b, 15);

    显示：
        Arguments(3)
        0: 10
        1: 5
        2: 15
        callee: ƒ add(a,b)
        length: 3
        Symbol(Symbol.iterator): ƒ values()
        __proto__: Object


回调函数：            函数是可以作为参数传递的 （一般都是回调函数）
回调函数的定义：如果一个函数被当作参数传给另一个函数,那么这个函数就被称作回调函数,虽然概念是这么定义的,
但是真正的回调函数还要符合下面几个特点,如果不符合我们不能称作是真正的回调函数
    1.函数是我定义的    
    2.从一个函数传到另一个函数不是我调用的
    3.最终执行了

回调函数本身被调用的时候函数名后面不要加(),否则就是自己在调用 
例子:
    function f1(){
        console.log(a);     
    } 
    
    button.onclick = f1;    表示每点击一次都会被调用f1函数
    button.onclick = f1();  这种格式时错误的,会直接显示调用结果

    用处： 
    事件                事件本身就是一个方法或者函数    写回调函数
    定时器 
    ajax 
    生命周期回调函数


0bject  实例对象
    1.对象的概念
        在js当中,可以说一切皆对象
        对象的概念：无序的名值对的集合（键值对的集合）

        如果储存一个简单的数据（一个数字、一个字符）  直接var a = 10;
        如果储存一堆的数据 此时我们想到数组 数组就是专门用来储存多个数据用的
        如果我们想要执行一段代码,或者让这段代码有功能,此时我们需要函数
        如果我想描述一个复杂的事物,比如一个人、一台电脑（需要用到多个属性或者方法才能描述清楚）,此时就要用到对象


    2.对象的创建方
        a       字面量创建
        b       New Object
        c       工厂函数模式

    3.对象遍历    for...in                    也可以遍历数组,但是只能遍历数组下标
                
                for(var key in obj){
                    console.log(key,obj[key]);
                }
        如果在遍历对象的时候,取值只能使用[]的方式,因为key是一个变量, 如果写成boj.key拿到的是undefined,
        key被认为是对象里面的属性。obj[key]的话,key被解释为变量,使用变量的值来进行替换 
        for..in枚举对象的属性的时候，除了能枚举自身的属性之外，还会枚举原型对象的属性
        obj.hasOwnProperty(key) ：只拿自身的属性
        
            if(  obj.hasOwnProperty(key)  ){
                console.log( key )          
            }


ES6对象扩展
    1. Object.is(v1,v2)
        判断2个数据是否完全相等
    2. Object.assign(target, source1, source2...)       target目标对象  source源对象 
        方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。
        它将返回目标对象。会修改目标对象上，并且返回目标对象
        也被叫做 克隆 拷贝
    3. ES6可以操作隐式原型 .__proto__ 属性
        obj.__proto__ = target;


二、构造函数创建特定实例对象 
1.构造函数的基本概念,使用,作用
    构造函数：本质上也是一个函数,只不过我们通常把构造函数的名字写成大驼峰
    在js当中,没有类的概念（ECMA5版本）,构造函数可以理解为类
    构造函数的用法和普通的函数用法是一样的,直接可以调用,只不过它比普通函数多了一种用法。
    构造函数当作普通函数执行,那么this代表的是window,构造函数的意思就是变为了window对象添加属性和方法

例如：
    function Animal(color) {this.color = color;}
当一个函数创建好以后,我们并不知道它是不是构造函数,即使像上面的例子一样,函数名为大写,我们也不能确定。
只有当一个函数以 new 关键字来调用的时候,我们才能说它是一个构造函数。就像下面这样：var dog = new Animal("black"); 

2.对this的讲解
            不同场合this指向不同
            window对象简介
                浏览器窗口对象,代码执行的时候所有的一切都包含在窗口对象下。

        this: 其实通常情况下在任何函数当中都会有this这个关键字 
        this本质是一个对象,代表着调用这个函数或者方法的对象（执行着）;    
        在函数当中,函数也可以叫做window对象的方法,this永远代表window
        在事件当中,回调函数当中的this,代表的是事件对象
        在对象的方法当中,this代表的是这个对象 
        在构造函数当中,代表的是实例化出来的对象

3.new关键字实例化对象的
            1、开辟内存空间
            2、this指向改内存
            3、执行函数
            4、生成对象实例

4.原型对象和原型链
    原型对象
        任何的函数对象在定义的时候都会伴随着一个原型对象的出现,原型对象默认的是Object的实例对象
        prototype
    原型对象的作用：

    原型链      对象在查找属性或者方法的进程

    构造函数创建实例化对象
    构造函数中会有prototype         指向原型对象    原型对象相当于是实例化对象的外部的公共区域
    原型对象中会有constructor       指向构造函数    每个原型对象身上都有一个constructor属性,该属性的目的是为了标识当前的构造器是谁    
    实例化对象会有_proto_           指向原型对象

    对象在调用方法(或者属性)的时候,首先会从自己对象的空间当中去找,如果找到了直接用
    如果没有找到,然后去自己的原型对象空间去找(自己构造函数的原型对象),如果找到就用
    如果没找到,然后去自己的原型对象的原型对象空间去找(自己的构造函数的原型对象的构造函数的原型对象当中去找),
    如果找到就用,如果找不到继续往上,直到找到Object的原型对象位置,找到就用,找不到报错。
    我们把这个对象找属性的过程形象的描述为原型链

5.apply和call可以让一个对象使用另一个对象的方法,(即把函数绑定this并且执行)并且立即执行函数
    让一个实例对象去调用window的方法(也就是我们所说的函数)
    把新的方法,给旧的对象:
        新函数或者方法.apply(旧对象,[函数调用时的参数]);
        新函数或者方法.call(旧对象,函数调用时的参数1,函数调用时的参数2);
    可以理解为新函数的this指向的是旧对象/旧函数
    或者新函数继承旧函数的this
    或者新函数的this指向旧函数

    bind
        并不会直接执行，用来预设this指向
        格式:        
            函数名.bind(this指向,调用时的参数)
            函数名.bind(this指向)(调用时的参数)
        可以理解为:   复制了一个同样的函数而且预设过this指向
        bind的作用
            1. 返回一个新的函数
            2. 新函数内部会调用原函数(通过call调用)
            3. 调用时指定原函数执行的this为bind()的第一个参数的值

    总结：
        call、apply都是绑定this并且调用函数
        bind是绑定this,并不调用,同时返回一个新的函数，

    例子：
        function fn(){
            console.log(this);
        }
        
        fn()                            //window

        fn2 = fn.bind({})
        fn2()                           //{}  本质是返回的新函数内部执行了fn.call({})
         

6.对象是那个构造函数的实例判断  instanceof
        
        typeof  ：      
            在判断基本数据类型当中的数字、字符串、布尔、undefined、函数的时候才可以派上用场 但是我们使用typeof去判断
        数组、对象和null的时候,区分不出来了
            console.log(type 被判断对象)                    //判断基本数据类型是那种数据类型       

        instanceof：
            可以判断是一个Array 还是一个其他构造函数实例对象
            通过判断这个对象是那个构造函数的实例对象,可以区分出来是数组还是其他的对象
            console.log(被判断对象 instanceof  构造函数)    //判断对象是那个构造函数的实例化对象
        
        == 专门用来判断null,如果相等就是null 
        
        总结：
        typeof        检测值类型                      string number boolean undefined  object function
        instanceof    用来判断A是否是B的实例化对象     A instanceof B  返回值是布尔值
        ==                                           null


三 值类型 引用数据类型 栈 堆

    1       值类型和引用数据类型的概念
                值类型： 基本数据类型   string number boolean undefined null
                引用数据类型：对象类型  object Array  function

    2       栈和堆的概念
                栈          栈          先进后出        桶      栈结构内存一般比较小,计算机自动分配内存,存储速度比较快
                堆          链表        随意的进出              堆结构内存一般比较大,底层需要程序员自己分配（js做了封装、会自动分配）
                                                               堆里面一般储存的都是一些比较复杂的占空间比较大的数据
                队列        队列解构     先进先出       管道

                堆和栈是内存的存数据结构：内存被开辟使用,就一定会被计算机回收(释放内存)

                

    3      值类型和引用数据类型与堆栈的关系（堆空间释放）
                堆空间的释放时靠垃圾回收机制进行的
                当程序函数或者整个程序执行完毕后,栈里面所有的东西都会被是发放销毁,堆当中的数据可能还在,只是没有任何的变量
            指向(引用)那么堆当中的数据就会变成垃圾对象。回收机制会在适当的时候将垃圾对象清理回收
                如果我们在程序当中需要去删除对象,那么就将这个对象的变量赋值为null,代表这个对象引用被改变,这个对象也就成为
            了垃圾对象,其实删除对象就是让堆当中的对象数据成为垃圾对象。

    4       一块内存包含两个数据类型
                内部存储的数据(一般数据/地址数据)    
                内存地址值数据

    5       内存分类
                栈结构：全局变量，局部变量(空间较小)
                堆结构(列表结构)：对象(空间较大)

            JS只有堆内存
                我们所说的栈和堆只是在大的堆内存里面两块分区
 四 内置对象JSON
    1       
            JSON是js当中的一个内置对象,里面封装了json格式数据的操作方法
            json是一种数据格式,是前后端目前数据交互的主要格式(xml)

            json通常情况下说的是字符串也叫做json串
            在前端json串的格式就是对象或者对象的数组,只不过要把这些数据转化成字符串形式
            {
                "name":"赵丽颖";
                "age":32;
            }

            [
                {
                   "name":"赵丽颖";
                    "age":32; 
                }
            ]

    2       JSon 对象方法的使用:
            stringify       把对象或者对象的数组字符串化,用以前后端交互,往后端传
            parse           把字符串返回为对象或者对象的数组,

            parse只能转换stringify转化过的字符串 而不能转化我们自己设定的字符串
            因此这两个需要互相配套使用

五Math工具对象

    1   Math对象的使用：
            ceil            向上取整        
            floor           向下取整
            round           四舍五入
            radom           随机数                  区别radio单选框
            max             最大值
            min             最小值
            PI              PI就是圆周率π,PI是弧度制的π,也就是180°所以,Math.PI = 3.14 = 180°
            pow             求方 第一个是底数 第二个是指数 
            abs             求绝对值
            

    例子：
        //用来处理小数,把消除最终处理成整数
        console.log(Math.floor(1.23));      //向下取整,结果为1
        console.log(Math.ceil(1.23));       //向上取整,结果为2
        console.log(Math.round(1.4));       //四舍五入,结果为1
        console.log(Math.round(1.5));       //四舍五入,结果为2

        //随机数 random
        console.log(Math.random());         //随机0~1之间的一个数,包含0不包含1

        //最大最小值
        console.log(Math.max(1,18,10,2,40));//返回多个数之间的最大值
        console.log(Math.min(1,18,10,2,40));//返回多个数之间的最小值

        console.log(Math.PI);               //数学当中的π(圆周率)

        console.log(Math.pow(3,4));         //求方 第一个是底数 第二个是指数  3的4次方

        console.log(Math.sin(Math.PI/2));   //三角函数在Math当中全部要使用弧度而不是角度
                                            //360度 = 2π = 2弧度    

         //随机函数的封装
        function getRandom(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

六 Date日期对象
        var date = new Date();                     拿到时间对象
        console.log(date);                         Mon Dec 14 2020 21:34:55 GMT+0800 (中国标准时间)
        console.log(date.getFullYear());           年 
        console.log(date.getMonth());              月 结果为0~11来代表1~12月,所以计算时记得+1
        console.log(date.getDate());               日  返回月份的某一天。
        console.log(date.getDay());                周  返回值是一周中的某一天0(周日)到6(周六)之间的一个整数
        console.log(date.getHours());              时
        console.log(date.getMinutes());            分钟
        console.log(date.getSeconds());            秒
        console.log(date.getYear());               已经废弃
        console.log(date.toLocaleTimeString());    用当地的时间   下午9:34:55
        console.log(date.toLocaleDateString());    用当地的日期   2020/12/14
        console.log(date.getTime());               从1970年1月1日到现在的之间的毫秒数
                    Date.now()                     比date.getTime更好用,不用new实例对象直接用
day9 
    包装对象:
    var a = 10;                     //基本数据类型
    var b = new Number(19);         //包装对象
    console.log(a.toString());      //10
    console.log(b);                 //Number

    a.toString a显然是一个对象才会有方法调用,但是a我们定义的时候是一个基本数据类型,它是没有方法的
        但是JS当中基本数据类型操作的时候有这么一个规定：
        当调用数字、字符串、布尔值的时候,会首先把这个值包装成对象(临时的),然后进行调用包装对象的方法,调用完成
        之后,临时的包装对象会立即清楚


    var arr1 = [ [1, 2],  [3, 4], [5, 6], [7, 8] ]; //  二维数组


一、 ES5严格模式 + ES6 定义变量(let + const)

    为什么要使用严格模式？
        消除JS语法的一些不合理、不严谨之处、减少一些怪异行为；
        消除代码运行的一些不安全之处,保证代码运行的安全；
        提高编译器效率,增加运行速度；
        为未来新版本的js做好铺垫

    严格模式主要都做了什么？
        1、 "use strict" 针对脚本(针对所有)写在脚本的第一行,如果想要只针对函数,那就写在函数体的第一行
        2、 变量声明必须写var,不写var直接报错
        3、 禁止this指向window,如果构造函数忘记写new那么this不会影响全局
        4、 禁止随意删除变量    delete
        5、 函数不能有重复的参数

    let使用及特点
        块级作用域声明变量(即使不是函数的{}、例如if(){}, for(){}也是仅仅在内部使用,外部看不到)      
        ES6都是处于严格模式下的
        let定义的变量不会进行预解析
        let变量不允许重复定义

    const使用及特点
        注意：const(英文翻译为常量),但是在这里定义的并不是常量
        它只是声明一个变量,变量的值无法更改,也是块级作用
        const定义的变量不可以修改,而且必须初始化

        例子: 一个数字1、一个数组[1,2,3],本身是常量
        let a = 1;
        var a = [1,2,3];
        a是变量

二、 String 方法 ES5
        es5所有的字符串操作,返回的都是新串,不能修改原字符串
        所有的字符串一定要搞定三要素： 功能 参数 返回值 😫

        charAt()                返回对应下标的内容
        charCodeAt()            返回字符串对应下标的unicode码
        String.fromCharCode()   根据unicode码返回字符串
        indexOf()               返回第一次查到的位置(索引),参2是从下标位置开始查找,如果没有查到返回-1
        lastIndexOf()           从后往前查第一次查找到位置  
        replace(/12/g,"**")     正则匹配寻找字符串然后替换
        match(//)               正则匹配寻找子串， 把找到的子串用数组方式返回来   等于正则exec
        search(//)              正则匹配 寻找子串 返回串位置                    等于正则test
        substr()                抽取子串,传递参数,第一个开始位置下标,第二个是长度length
        substring()             抽取子串,和slice很像,但是参2不能传递负数 
        slice()                 抽取子串,传递参数起始位置,但是不包含结束位置 顾头不顾尾 即结束位置是参数2-1
        split()                 以参数为分割标志,将字符串转化为数组,传递的参数在数组当中不复存在,必须是("")才能把每一个子串单独分割
        toLocaleUpperCase()     转本地大写
        toLocaleLowerCase()     转本地小写
        toLowerCase()           把字符串转小写
        toUpperCase()           把字符串转大写
        toString()              转化为字符串,返回的还是字符串本身
        valueOf()               转化为字符串,返回的还是字符串本身
        localeCompare();        原字符串和传参字符串进行比较  返回 1代大 -1代表小 0代表相等
        concat()                返回拼接后的字符串

        发音chun~                       
        trim()                  如果参数有值的话看参数，从字符串的两端删除空白字符。
                                在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等)以及所有行终止符字符（如 LF，CR等）。      
    
三、 string方法ES6
    1   includse(str)       判断是否包含指定的字符串
    2   starWith(str)       判断是否以指定字符串开头
    3   endsWith(str)       判断是否以指定字符串结尾
    4   repeat(count)       指定重复次数

四、 Array 数组的方法        数组的方法都要记住

ES5方法：
    concat()            数组后面拼接参数,返回一个新数组,参数可以是一个或者多个,甚至是一个数组,传入的参数数组会被拆分

    join()              返回一个新的数组,把数组转化为字符串,()可以指定用什么拼接字符串,像字符串的split的一个逆运算
                        根据传入的参数为界把数组分割为字符串,("")表示每个元素挨在一起,(" ")表示空一格
    reverse()           翻转原数组,返回原数组,原数组会被改变

    slice()             截取传递参数起始位置,但是不包含结束位置 顾头不顾尾,返回一个新的数组,不影响原数组
    
    push()              返回添加后的length,在原数组的末尾添加元素,影响原数组,遇见啥加啥,如果添加数组,原数组会改为二元数组,而不是把添加的数组拆分
    
    pop()               返回删除的元素,从原数组的数组末尾删除一个元素,影响原数组
    
    unshift()           返回添加后的length,从原数组头部添加一个元素,影响原数组
    
    shift()             返回删除的元素,从原数组头部删除一个数组,影响原数组
    
    splice              可以增、删、改,都是在原数组基础上进行的,参1开始位置,参2是删除长度,参3增加的元素
    
    toString()          把数组转为字符串  其实就是数组内的内容
    
    toLocaleString()    把数组转为本地字符串  其实就是数组内的内容                
    
    sort()              给数组进行排序,排序也会影响原数组,在原数组上进行排序
                        如果不传参,会按照unicode码进行比较排序,类似于字符串比较,（从第一个元素或者字母开始比较）
                        如果传参,需要一个回调函数,按照从小到大排序排序a-b<0 ,从大到小排序b-a>0
                        还可以根据数组中的对象的某个属性值进行排序
    sort(function(a,b){ return a - b;})    影响原数组   
                        从小到大排序(第一个参数-第二个参数 <0)  
                        从大到小排序(第二个参数-第一个参数 >0)

           

五 Array方法 ES5 + ES6

    ES5
    1   Array.prototype.indexOf(value)          得到值在数组中的第一个下标
    2   Array.prototype.lastiIndexOf(value)     得到值在数组中的最后一个下标
    3   Array.prototype.forEach(function(item, index){})  数组遍历
    4   Array.prototype.map(function(item, index){})      加工 遍历数组返回一个新的数组,返回加工之后的值

            item代表数组的元素  index代表数组的下标
            map()   方法返回一个新数组,数组中的元素为原始数组元素调用函数处理后的值
            map()   方法按照原始数组元素顺序依次处理元素
            注意: map() 不会对空数组进行检测
            注意: map() 不会改变原始数组

    5   Array.prototype.filter(function(item, index){})   判断 遍历过滤出一个新的子数组,返回根据判断条件成立的值
            arr.filter(fullName(item){
                return item > 0                            retuen 表达式结果必须为Boolean
            })

           
    ES6
    1   Array.from(v)                           将伪数组对象或可遍历对象转化为真数组
    2   Array.of(v1,v2,v3)                      将一系列值转换成数组
    3   find(function(value, index, arr){return })             找出第一个满足条件返回true的元素
    4   findIndex(function(value, index, arr){return true})    找出第一个满足条件返回true的元素下标
            


总结：
    string重要的：

        charAt()            返回字符串对应下标的内容
        indexOf()           返回子串第一次出现的位置下标,参2是从下标位置开始查找,如果没有查到返回-1
        lastIndexOf()       返回子串最后一次出现的位置下标
        split()             以传递的参数为分割标志,把字符串分割为数组,("")默认是每个子串都分割，也可以根据参数分割
        replace(/参/g,参)   正则匹配寻找字符串然后替换
        slice               截取数组、字符串,不影响原数组或者字符串 参1开始,参2-1是结束位置

    Array重要的：
        concat()        数组后面拼接参数           
        slice()         截取数组、字符串,不影响原数组或者字符串 参1开始,参2-1是结束位置
        splice()        增删改,返回一个操作后生成新的数组,参1开始位置,参2是删除长度,参3增加的元素,会有影响原数组 
        join("")        根据传入的参数为界把数组分割为字符串,("")表示每个元素挨在一起,(" ")表示空一格
        substr()        根据length截取数组
       
数组的定义方式
    var arr = [1,2,3];                  字面量定义
    var arr1 = new Array(1,2,3);        构造函数定义
    var arr2 = Array(1,2,3);            普通函数定义
    Array.of(1,2,3);                    [1,2,3]             Array.of(3);  ===> [3]



数组要小心的坑
    数组new Array 或者 Array 如果传的是多个值,会生成数组的元素,
    如果只传一个值n,那么定义的是数组的长度,及n个undefined
        var arr3 = new Array(3);        //3个undefined
        var arr4 =  Array(3);           //3个undefined

    扩展，以后常用的reduce:根据数组中元素进行统计处理(累计/累加) 
    const arr = [1,3,4,5,7]
    const total = arr.reduce((preTotal, item) => preTotal + item, 0)    //求和
    const total = arr.reduce((preTotal, item) => preTotal + (item%2===1? item : 0), 0)  //求偶数元素和

    相当于求和
    let result = 0
    arr,forEach(item => {
        result += item
    })


Day10 DOM上

第一节：DOM概念和操作方式

1   DOM概念：作用、顶级对象
    DOM 文档对象模型
    DOM是一个使程序和脚本有能力动态地访问和更新文档的内容、结构及样式的平台和语言中立的接口
    DOM描述了处理网页内容的方法和接口

    window是浏览器窗口对象,所有的东西都是被当作window的子对象

    文档对象模型        documengt是window下的一个属性,代表整个DOM文档对象

    节点                元素    属性    文本    注释
    元素                标签
    根元素(root)        HTML标签
    文档树(dom树)       以HTML为根节点  形成一颗倒立的树状结构，我们称作DOM树：这个树上所有的东西都叫做节点
                       这些节点如果我们通过DOM方法去获取或者其他的操作去使用的话，就叫做DOM对象


2   window.onload      页面加载完成事件

    window.onload = function(){

        等待页面加载完成，执行函数当中的代码
    }


第二节：获取DOM对象，操作DOM对象，事件绑定，操作元素属性：

1.      document.getElementById
            这个是document下的一个方法，通过id获取相关元素，封装为dom对象返回

2       点击事件    onclick

        事件三要素          事件源(长寿事件的对象)              事件                事件处理回调函数
        事件处理三大步      获取事件源DOM对象                   添加事件监听         书写处理回调
        事件写好之后可以重复出发执行


setAttribute和getAttribute的用法：      获取属性节点
        
    在操作元素属性的时候.语法只能操作元素天生具有的属性，如果是自定义的属性通过node.语法是无法操作的，
只能通过setAttribute和getAttribute去操作，他俩是通用方法，无论是天生的还是自定义的属性都可以操作    
    
    setAttribute("需要改变的属性","属性被改变后的值")
    getAttribute("属性")        获得对应的值

node.class是不合法的,因为class是js的保留字,所以不能占用,因此以后操作class属性要用className

第三节:     练习


第四节:     循环绑定事件+操作元素内容：
获取节点的方法:
    0.  document.getElementById         通过ID获取,并且只能获取一个元素
    1.  document.getElementByTagName    通过标签名获取,并且获取的是多个,返回的是数组,哪怕标签只有一个返回的也是数组
    2.  document.getElementByClassName  同过class的属性获取,并且获取的是多个,返回的是数组,哪怕标签只有一个返回的也是数组     
    3   document.querySelect            通过选择器查询获取一个  querySelect(#class) querySelect(.id)
        document.querySelectAll         通过选择器查询获取全部  

        querySelect专门用来获取选择器中只有一个元素,返回的是单个元素dom对象
        querySelectAll专门用来获取选择器中多个元素,返回的也是数组

重点 必考

排他操作修改文本内容:
    1.让所有的都成为一种样式
    2.第二步让当前发生时间的对象独自成为一种样式

    for循环对多个对象添加事件的时候,当时for循环只是添加了事件监听,而事件回调函数是不会执行的,事件回调函数当中的代码
是在事件发生的一刹那执行的,但是此时,for循环早都已经执行完毕,所以在事件函数当中只要出现了循环变量就肯定报错


例子：例如<h1>内容<h1/> 
设置标签文本内容:
        innerHTML       设置内容的时候,节点内的标签会解析生效,在页面上生效              输出解析后的大内容 
        innerText       设置内容的时候,会把标签原样展示在页面上,不会解析,也不会生效      输出:<h1>内容<h1/>
        textContent     设置内容的时候,会把标签原样展示在页面上,不会解析,也不会生效      输出:<h1>内容<h1/>

读取内容的时候：    
        innerHTML    节点内的标签输出,可以获取隐藏元素的文本,包括换行和空白都可以拿到       拿走全部:<h1>内容<h1/>、标签、隐藏、空白、换行
        innerText    节点内的标签不输出,拿不到隐藏文本,并且拿不到包括换行和空白,           只拿:标签里的内容
        textContent  节点内的标签不输出,可以获取隐藏元素的文本,包括换行和空白都可以拿到     只拿:内容、隐藏、空白、换行


注意    innerText                       拿不到空白和换行,无论换行几次都只解析为一个空格
        这里拿不到的隐藏元素仅仅指的是    style="visibility: hidden;"属性下
                     
隐藏
    (style="visibility: hidden;")   隐藏元素的内容,标签不会显示出来,但是会占据空间和位置
    visibility:hidden;              占位置但是不显示
    display: none;                  不占位置，元素直接消失
    opacity: 0;                     透明度为0
    overflow:hidden                 移出的部分隐藏
    width:0;                        
    height0;
    transform                       位移出页面

    <div  onselectstart="return false"></div> 让标签内的内容无法被选中,行内样式
使用样式
    node.innerHTML = "需要输出的内容"                   在网页标签上输出内容
    node.innerHTML = "<h1>"+变量+"</h1>"               用""拆解标签,以此来拆解标签输出内容  
    node.innerHTML                                     本身是网页标签当前拿到的内容



第五节 鼠标事件 + style样式操作,操作元素样式

    鼠标事件：
        onmousemove         鼠标移动
        onmouseover         鼠标移入(悬浮)     组成一对     
        onmouseout          鼠标移出           组成一对
        onmouseenter        进入    组成一对
        onmouseleave        离开    组成一对
        onclick             点击
        onmousedown         鼠标点下的时候
        onmouseup           鼠标抬起的时候
        ondbclick           鼠标双击、几乎不用

        onmouseover  onmouseout    在向嵌套的内部div移动的时候会同时触发移入移出
        onmouseenter onmouseleave  在向嵌套的内部div移动的时候不会同时触发移入移出
        即在向内部嵌套的子元素移动的时候一个会触发事件，一个不会触发事件

第六节  兼容性封装设置读取内容函数

1.浏览器兼容性讲解
    浏览器有很多 Chrome、火狐、IE Opera safari 
    浏览器最终分为两个阵营：高级浏览器和IE低版本浏览器(IE8是分水岭)   

    innerText       什么浏览器都认识
    textContent     只有高级浏览器认识、想要低版本也兼容需要封装兼容性处理函数   
 
Day 11 DOM下
第一节  
几乎都是用在表单元素上面：
    on
        keydown     键盘按下    按下一直不松手会一直触发事件
        keyup       键盘抬起
        focus       获取焦点
        blur        失去焦点

 显示键码ASCII码值 例如回车是13       event英文翻译：事件
    Node.onkeydown = function(event){
            console.log(event.keyCode);        
        }

<div tabindex="100">哈哈</div>
div默认没有获取焦点、当给div添加 tabindex:正数 属性之后才会有获取焦点属性

Day 12 节点
获取元素节点的方法
        document.getElementById(id);
        document.getElementsByName(name属性的值)    
        document.getElementsByTagName(标签名)           
        document.getElementsByClassName(class名字)
        document.querySelector(CSS选择器)
        document.querySelectorAll(CSS选择器)

获取属性节点的方法：    几乎不用
    例子：<input type="text" class="aa" value="bbb">
        node.getAttributeNode("class");             //根据属性名称,获取节点上,某一个名为xx属性节点      class="aa" 
        node.getAttributeNode("class").nodeValue;   //一般在属性节点上，返回属性节点的值                aa
        node.getAttribute("class");                 //直接获取节点上名为xx属性的值                     aa
        node.attributes;                            //获取这个节点上所有的属性节点集合对象              NamedNodeMap{}
        node.attributes.getNamedItem("class");      //获取节点属性集合中名为xx属性的属性节点           class="aa" 
        node.removeAttribute("checked")             //删除属性节点
    
获取元素节点的时候有两个特殊的html和body节点：
        两种方式都可以获取html节点 
            document.documentElement;
            document.querySelector("html"); 

注意:html节点拿到的不包含第一个和最后一个文本节点(即前面的换行和空格)、在body中写的元素会带上第一个和最后一个

        两种方式都可以获取body节点 
            document.body;
            document.querySelector("body");

什么是节点：文档树包括的所有东西都可以称作节点,最关注的是元素节点
    查找节点是相对的操作,如果你拿html的子节点,就是html当中所有的节点,但是不包含后代节点,只是子节点

    操作节点的方法：
    childNodes      以NodeList为对象名,返回节点下的所有子节点
    nodeName        返回指定节点的节点名称.
    nodeType        返回以数字值代表-节点类型。
    nodeValue       返回节点的值，其中属性节点和文本节点是有值的，而文档节点和元素节点没有值null。

文档当中都是节点： 元素、文本、属性、注释。。。。。。
    节点分类有12中,重点了解3种,元素、属性、文本节点：  
        元素     如果是元素节点 nodeType == 1       nodeName == 标签名        nodeValue ==  null
        属性     如果是属性节点 nodeType == 2       nodeName == 属性名        nodeValue == 属性的值
        文本     如果是文本节点 nodeType == 3       nodeName == #text        nodeValue == 换行空白、或者文本内容
        注释     如果是文本节点 nodeType == 8       nodeName == #comment     nodeValue == 注释的内容


    子节点和子元素(节点)
        childNodes      拿到的是某个节点下的:子节点(包括元素子节点和文本子节点,如果有注释还有注释节点)
        children        单纯的拿某个节点下的:子元素节点

        子节点:childNodes(儿子节点):
        高级浏览器:元素、文本(包括空格、换行)、注释
        低版本浏览器:元素、文本(不包括空格、换行)、注释

        子元素children(儿子元素):
        高级浏览器:元素
        低版本浏览器:元素、注释

    父节点和父元素(节点)
        parentNode          父节点、其实就是父元素  所有浏览器都可以使用
        parentElement       父标签、所有浏览器都可以使用
    
    其他节点获取：
        firstChild              第一个子节点            都可以用
        fristElementChild       第一个子元素节点        只有高级浏览器可以使用
        lastChild               最后一个节点            都可以用
        lastElementChild        最后一个子元素节点       只有高级浏览器可以使用
        previousSibling         上一个兄弟节点          都可以用
        previousElementSibling  上一个兄弟元素节点      只有高级浏览器可以使用
        nextSibling             下一个兄弟节点          都可以用  
        nextElementSibling      下一个兄弟元素节点      只有高级浏览器可以使用


节点常用的方法：  增删改查
创建节点\增加节点的三种方法：   增
1  document.write()           只能在页面加载过程中使用,如果页面加载完后,再使用会将其他的dom干掉       根本不用
2  parentNode.innerHTML =     会覆盖内容所以,要把之前的内容和需要的添加的内容,重新用字符串添加上去      常用
3  document.createElement(想要创建的元素名)               创建一个新的节点                           常用

以下操作都是在父节点下操作：
parentNode.
            insertBefore(新节点,参照节点)           插入节点,在参照节点之前插入节点
            replaceChild(新节点,被替换的节点)       替换节点   
            removeChild(被删除的节点)               删除节点
            appendChild(被追加的节点)               子节点末尾追加、添加节点
            

node.remove (pc端 ie浏览器不支持)





Day13   DOM事件绑定和解绑(要对应)

DOM 0 1 2 3

    DOM0和DOM2  有自己独立的事件绑定和解绑方式
    DOM1和DOM3  没有

    Dom0事件的  绑定和解绑         如果是dom0事件，不能对同一元素添加同种事件多次，会被覆盖
        on+绑定的事件
        node.onclick = null;    Dom0的事件解绑,本质上就是把事件函数和事件对象的事件属性断开指向

    Dom2事件的  绑定和解绑          DOM2事件可以再元素身上添加多个相同事件,不会被覆盖可以添加同一类事件多次
        
    绑定    addEventListener("click", fun, false)          事件名  事件函数  默认冒泡false可以省略不写
    解除    reomveEventListener("click", fun, false)       事件名  事件函数  默认冒泡false可以省略不写
    事件解绑,函数必须放在外面去定义,如果不放在外面定义,直接在参数当中写匿名函数表达式,那么绑定和解绑传的回调函数不是
同一个,所以解绑不了



    dom0    onclick /on事件名           事件所有的浏览器都可以使用      
    dom2    addEventListener()          绑定事件    高级浏览器可以使用  IE10一下不可以使用      
            removeEventListener()       解除事件    高级浏览器可以使用  IE10一下不可以使用
            event.stopPropagation()     阻止冒泡
            event.preventDefault        阻止默认行为 例如a标签点击不进入网页
兼容            
    dom2    IE10一下给出了另一种绑定方式：
                obj.attachEvent("on"+ eventType,fn)         on+事件名称     添加的事件函数   
                obj.detachEvent("on"+ eventType,fn)         on+事件名称     解除的事件函数 


    解决Dom0取消默认行为:比如ctrl+a 全选文字会被拖动
            return false;
    
    解决DOM2的addEventListener()方式添加，onclick的时候A标签防止触发没有效果的问题：

        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }  


    box.setCaptrue && box.setCaptrue();             事件捕获
    box.releaseCapture && box.releaseCapture();     解除事件捕获

事件流 （事件传播）
    1.  捕获事件流(网景)        几乎不用
    2.  冒泡浏览器(ie)          最终我们所用的事件传播都是冒泡
    3.  标准DOM事件流           里面包含三个阶段:有捕获、再去获取元素、最后冒泡

    dom0事件全部默认属于冒泡  
    
        标准DOM事件流这三个阶段当中的捕获和冒泡可以由程序员自己选择, 但是通常情况下我们默认使用(冒泡)：
            true                        捕获      嵌套模式,都添加的有事件,触发一个,会从外向里传递,逐个触发
            false                       冒泡      嵌套模式,都添加的有事件,触发一个,会从里向外传递,逐个触发
            event.stopPropagation()     阻止冒泡,阻止事件,传递逐个触发


    例子：
        哪个鼠标按钮被点击？
        光标的坐标是？
        被按的按键的 unicode 是？
        相对于屏幕，光标的坐标是？
        哪个元素被点击了？
        哪个事件类型发生了？
        shift 键被按了吗？ 


事件冒泡、事件委派、及阻止事件冒泡：
    事件冒泡的好处：
        就是可以进行事件委派(事件委托,事件代理)
    事件委托用法：
        什么时候用:出现新添加的东西,并且新添加的东西要和老的拥有同样的行为,此时我们就想事件委派
    事件委派的做方法：
        给爹添加事件,不给元素本身添加,事件发生后通过爹去找,真正发生事件的元素是谁进行处理;

    event.target ||event.srcElement :  
        target事件属性可返回事件的目标节点(触发该事件的节点),如生成事件的元素、文档或窗口。
        通过target找到嵌套形式的节点中那个儿子触发的事件

    例子：
          ulNode.onmouseover = function(event){
            event.target ||event.srcElement :  
            var liNode = event.target;                      //在里面去找发生事件的儿子
            liNode.style.backgroundColor = "lightblue"
        }

    通过给父ul添加事件,通过target找到那个儿子触发的,通过事件冒泡,实现效果

        
    onmouseenter onmouseleave  事件并没有移入,移出,然后再移入,也就是说事件元素没有切换。

        如果是一个父元素模型,对父元素添加移入和移出,当鼠标移入父元素里面的子元素的时候
   
    onmouseover  onmouseout     事件会有移入,移出,然后再移入,也就是说事件元素会有切换。
                                事件委派的时候、或者里面有子元素的时候，必须使用这一对,
        
BOM是浏览器窗口对象:
    location    window.location可以用户获取当前页面地址及重定向到一个新的页面,
                window.location.href    可以读也可以写,写的时候相当于转向另一个页面
    history     对象包含浏览器的历史记录,window可以省略,这些历史记录以栈(FIFO)的形式保存,页面前进则入栈,后退出栈
    navigator   是一个只读对象,它用来描述浏览器本身的信息,包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息
    screen      提供了用户显示屏的相关属性,比如显示屏幕的宽度、高度、可用宽度、高度

window对象是所有对象的顶级对象
    DOM是挂在document下的,但是document也是在window下面的
    BOM是浏览器窗口对象,也是在window下面

1.  window对象概念
        function add(){}        写函数其实是挂在window下,添加的函数
        add()                   调用函数其实是调用window,下的函数,只不过是简写了
        window.add()  
                  真正的写法应该是window.add()
2.  window.onload
    window.onresize     浏览器窗口发生改变，就会执行这个事件

day 14 

单次定时器/延迟定时器：
    一般用来左延迟效果 ,是window下的一个全局方法,两个参数,一个是回调函数/后者是一段执行代码,一个是时间毫秒1000=1秒
    后面还可以跟多个参数

    

    setTimeout(回调函数,毫秒,无数个参数)             设置延迟单个定时器

    clearTimeout(原来的定时器)                      清除延迟单个定时器

    setInterval(回调函数,毫秒)                      设置多次定时器          重复循环

    clearinterval(原来的定时器)                     清除多次定时器          重复循环


    例子：
        var timer =  setTimeout(function(){}, 5000);            设置
        
        clearTimeout(timer)                                     清除
    
    注意:
        清除延迟定时器:一定要把原来设置的定时器完整的写下来,或者设置定时器时字面量命名,清除时容易写

        定时器是一个异步操作：不是写在setTimeout(不是这里面的代码不会被延迟)

        写多个重复的定时器都会有效果，而不是被覆盖

        定时器定义的时候一定要是全局变量,他是window下的方法


        setTimeout(function f1(a, b, ...values) {
            console.log(arguments);         //形参伪数组[10，20，30，40]
            console.log(values);            //实参比形参多余的参数入真数组[30, 40]
        }, 1000, 10, 20, 30, 40);           //1000是设定的时间 10，20，30，40传的参数





事件对象event：
           var event = event || window.event;               event事件对象的兼容处理  
触发对象：
           var target event.target ||event.srcElement;      触发对象兼容性处理  
    解释：
        event对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态,
        事件通常与函数结合使用，函数不会在事件发生前被执行！   

    event
        系统给我们封装的,任何事件都会有这个event对象,就是回调函数的第一个形参

鼠标位置 （相对于左上角）
    offsetX     offsetY     相对于元素本身     
    clientX     clientY     相对于视口(浏览器收藏栏下的位置)即使有滚动条滑动,也是相对于现在窗口的左上角
    pageX       pageY       相对于页面,如果有滚动条滑动,相对位置是页面原始位置要加上滚动条滑动距离
    screenX     screenY     电脑屏幕的左上角,即把浏览器缩小后移动,还是以屏幕的左上点为坐标,点击位置距离当前电脑屏幕的距离 



js永远操作的是行内样式  

元素的大小和位置:

offset 系列只读              
    offsetWidth     拿的是盒子的content + padding + border 的大小
    offsetHeight
    offsetLeft      拿到是盒子的偏移量,也就是拿到这个元素定位的left和top值,相对的也是离他最近的定位祖先元素的原点
    offfsetTop      通常我们以来的偏移量去读取元素的位置offsetLeft、offseTop一定和定位相关
                    设置的时候通过style.left等去设置


client 系列只读      
    clientWidth     拿的是盒子的content + padding 的大小
    clientHeight
    clientLeft      拿到是盒子的边框border
6    clientTop   

    视口宽高求法
        documengt.documengtElement.clientWidth
        documengt.documengtElement.clientHeight

    以后我们拿元素的宽高、先看边框,没边框clientWidth和offsetWidth是一样的
    如果有边框,看需求：
        offsetWidth     带边框
        clientWidth     不带框
        scrollWidth     几乎不用

scroll 
    scrollWidth     只读,   当内容比盒子小的时候拿的是盒子的clientWidth,当内容比盒子大的时候,
    scrollHeight            拿到是内容offsetWidth+ 内容到盒子的一侧距离,即内容的完整
    scrollTop       可写,有滚动条的时候拿到是内容滚动的距离，（不是滚动条的距离）用于导航跟随 
    scrollLeft      可写,有滚动条的时候拿到是内容滚动的距离，（不是滚动条的距离）用于导航跟随


拖拽    点击元素拿到元素的初始位置和鼠标的初始位置          offsetLeft    clientX
        移动的时候拿到的最后位置可以求初鼠标的距离差
        元素最终的位置= 元素初始位置+鼠标距离差


        点击拿鼠标相对于元素本身的相对位置      offsetX 
        然后鼠标的移动移动后位置-相对位置       clientX -  offsetX 


取消浏览器默认行为:比如ctrl+a 全选文字会被拖动
        box.setCaptrue && box.setCaptrue();             事件捕获
        box.releaseCapture && box.releaseCapture();     解除事件捕获
        return false;                                   Dom0
        event.preventDefault                            Dom2

元素拖拽边框问题：html宽高- 元素本身的宽高
        if (lastX > document.documentElement.clientWidth - box.offsetWidth) {
            lastX = document.documentElement.clientWidth - box.offsetWidth;
        } else if (lastX < 0) {
            lastX = 0;
        }

        if (lastY > document.documentElement.clientHeight - box.offsetHeight) {
            lastY = document.documentElement.clientHeight - box.offsetHeight;
        } else if (lastY < 0) {
            lastY = 0;
        }


导航移动一段距离后固定跟随例子：
     window.onscroll = function () {
            //系统滚动事件,滚动距离依据浏览器的不同而不同,有些以html的滚动距离、有点是认为是body的滚动距离
            var scrollT = document.documentElement.scrollTop || document.body.scrollTop;
            if (scrollT >= 600) {
                div.style.position = "fixed";
                div.style.left = "0px";
                div.style.top = "0px";
            }
        }

注意：html的很多属性都是作用在document身上的、比如background-color

初始包含块：

    document ==>初始包含块 ==> html ==> body    这才是浏览器真正的层级

    初始包含块的大小：是第一屏视口的大小,在没有相对定位relative的时候,其他定位相对的都是初始包含块的位置
进行定位的,而不是html。

获取元素到视口上方和左边的距离：
    getBoundingClientRect() 会输出一个对象包含left top
    getBoundingClientRect().left        拿元素距离视口的left
    getBoundingClientRect().top


系统滚动条：
    html和body这两个元素overflow-scroll、overflow-hidden属性，控制着系统的滚动条的开关
    系统的滚动条有两个,一个是body身上的，一个是document身上的。我们平时看到的那个是document身上的。
    如果想要控制系统滚动条那个显示那个关闭分以下情况：

    1.单独给body或者html 设置overflow:scroll 滚动条打开的全部都是document的

    2.如果连个元素同时设置overflow属性：
        body设置的是scroll,html设置的是hidden,那么document的滚动条关闭,body身上的滚动条打开
        body设置的是hidden,html设置的是scroll,那么document的滚动条打开,body身上的滚动条关闭

    3.如果两个元素同时设置overflow:hidden,那么系统的两个滚动条全部被关闭

    4.如果两个元素同时设置overflow:scroll,那么html会打开document身上的,body打开自己身上的滚动条


总结：  如果body和html单独一个设置overflow的话都可以控制document
        如果两个都设置的话,html控制doucument,body只能控制自己

如何禁止系统滚动条：
    html,body{
        height:100%;     
        overflow:hidden;
    }
        
    //设置高度等于初始包含快、只有内容被超出才会被隐藏或者出现滚动条
    如果不设置height:100%,那么body和html高度将由内容自动撑开，也就是body当中的内容永远不会一处     


自制滚动条(布局)
    我们的页面架构首先要清楚
    页面最外层是document，紧接着是初始包含快、html、body、其次是我们的元素
    我们禁止了系统的滚动条,（因为各大浏览器的系统滚动条风格都不一，可能会禁止我们的页面布局）
    所以在body当中我们一般会有最外的一个盒子模拟body区域,在这个盒子的右边会定位一个盒子模拟滚动条

    滚动条比例
        滚动条按钮的高度 / 屏幕的高度 = 屏幕的高度 / 内容的高度 = 滚动条按钮的移动距离 / 内容的滚动距离



滚轮事件
        ie/chrome:mousewheel(dom2的标准模式)     ie 谷歌浏览器
            event.wheelDelta
                上：120
                下：-120
        addEventListener("mousewheel",function(){
            event.wheelDelta
        })



        firefox:DOMMouseScroll(dom2的标准模式)   火狐浏览器
             event.detail
                上：-3
                下：3
        addEventListener("DOMMouseScroll",function(){
            if(event.detail < 0){
                上
            }else if(event.detail > 0){
                下
            }
        })


正则表达式
    正则表达式式描述字符模式的对象
    
    字面量创建
        var patt =/pattern/ modifiers
    构造函数创建
        var patt = new RegExp(pattern，modifiers)

    pattern(模式) 描述了表达式的模式
    modifiers(修饰符) 用域指定全局匹配、区分大小写的匹配和多行匹配

    注意：当使用构造函数创建正则对象时，需要常规的字符转义规则(再前面加反斜杠 \ ) 比如以下时等价的
    var re = new Regexp("\\d+")
    var re = /\d+/


证的表达式规则写法
    修饰符
        修饰符用域执行区分大小写和全局匹配
        i:忽略大小写显示
        g:执行全局匹配(查找所有匹配而非在找到第一个匹配后停止)
        m:执行多行匹配

    方括号
        方括号用于查找某个范围内的字符
        [abc]       查找    abc(可以是123或者其他)任意一个 
        [^abc]      查找不是abc(可以是123或者其他)的任意一个
        [a-z]       查找任意一个小写字母
        [A-Z]       查找任意一个大写字母

    元字符
        .       任意字符不包含\n(换行和结束符)
        \d      任意数字        等价于[0-9]
        \D      任意非数字      等价于[^0-9]
        \w      任意单词字符也就是：数字 字母 下划线  [a-z A-Z 0-9 _]
        \W      任意非单词字符                      [^a-z A-Z 0-9 _]
        \s      任意空白字符
        \S      任意非空白字符
        \b      单词边界
        \B      非单词边界
        \n      换行符
        \f      换页符
        \r      回车符
        \t      制表符
        \v      垂直制表符

    量词
        +       1个或者多个前一个字符       \d+
        *       0个或者多个前一个字符       \d*
        ?       0个或者1个前一个字符        \d?
        {n}     连续n个前一个字符           \d{2}        
        {m,n}   连续m到n个前一个字符        \d{2,4}
        {m,}    连续至少m个前一个字符       \d{2,}
        $       结尾                      ^\d{11}$  以11个数字开头且以11个数字结尾：严格匹配 也就是字符串必须是11位数字
        ^       开头                        

    贪恋和非贪婪
        量词后面加？代表贪婪

    分组
        ()      分组后的反向引用            (\d{11})\1;

    



字符串正则相关方法
    正则对象的方法：
        Reg.test()
            test()方法用于检测一个字符串是否匹配某个模式,如果字符串中含有匹配的文本,则返回true,没有则返回false
            判断字符串当中是否含有数字           /\d/
            判断字符串当中是否含有abcd          /abcd/
            判断字符串是否是一个11位的数字      /^\d{11}$/

        Reg.exec()
            exec()方法用于检索字符串中的正则表达式的匹配
            该函数返回一个数组,其中存放匹配的结果,如果未找到匹配,则返回值为null
            注意:次方法每次只会返回一个结果,如果要找到所有的,需要循环去调用必须全局匹配修饰

            找到字符串当中符合正则的子串
            找到字符串当中所有符合正则的子串

        字符串方法使用正则
            str.search():字符串搜索符合规则的内容,搜索到就返回出现的位置(从0开始,如果匹配的不只是一个字母,那只
            会返回第一个字母的位置,如果搜索失败就返回 -1    只能返回一次)

            str.match(): 字符串当中搜索符合规则的内容,搜索成功就返回内容,格式为数组,失败就返回null,如果不加g
            那么返回第一次符合结果,如果加g返回所有结果的数组

            str.replace():查找符合正则的字符串,就能替换成对应的字符串,返回替换后的内容
                这个方法想到与做了两件事    先查找  然后再用新的串把匹配到的串替换掉    


            注意：上面两个方法类似正则的方法 test 和 exec
                Reg.exec()和str.match()
                当不使用全局匹配时,两者的匹配效果都是返回第一次匹配成功的结果：

                Reg.test()和str.search() 前者返回的是true或者false  后者返回匹配到的子串位置或者-1




               
js高级总结
一、数据结构、内存篇
    1.变量理解
        作用，用来保存数据，保存的数据可以改变
        本质，变量本身也是数据，也需要在内存中占用空间，保存在内存的栈结构分区中

    2.常量理解
        用来保存数据，保存的数据不可以被修改
        本质，变量本身也是数据，也需要在内存中占用空间，保存在内存的栈结构分区中

      js数据类型可以分为：基本数据类型和复合数据类型
    
    数据类型
        1.基本数据类型
            String    Number      Boolean     null    undefined
            特征：基本数据类型赋值给某一个变量以后，值本身不会发生改变
        

        2.复合数据类型
            function    Object      Array
            特征：引用数据类型的值可以通过赋值的变量进行修改

    
    内存分类：
        1.栈结构内存(数据结构：栈结构--->先进后出,后进先出),通常用来保存变量对象
        2.堆结构内存(列表)--->用来保存对象(数组、函数、对象)

二、函数篇
        1.函数也是对象
        2.函数具备行为，可以被调用
        3.减少代码量，复用、隔离变量，防止被污染

    函数分类
        1.普通函数
        2.构造函数
        3.IIFE(匿名函数自调用)
        4.回调函数(事件的回调，定时器的回调)

    函数的this
        1.理解this：
            关键字
            变量
        2.this的指向问题
            函数this不是函数定义的时候决定的
            函数thsi指向谁看如何调用当前的函数
        3.this指向分类
            函数自调用：window
            构造函数(new function):当前构造函数的实例化对象
            对象.方法():对象本身
            fun.call/apply(指向的对象):指向的对象

    原型
    什么是原型对象
        1.每个函数都有一个prototype属性，改属性指向的是原型对象(显式原型对象)
        2.每个实例对象身上都有一个__proto__属性，该属性指向也是原型对象(隐式原型对象)
        3.构造函数的显式原型 === 当前构造函数实例对象的隐式原型对象
        4.原型对象的本质：普通的object实例,并且初始化的时候是空的对象,后期添加的constructor,该属性指向
        当前的构造函数本身
        5.实例身上的__proto__为什么要隐式原型??当初设计的时候规定不允许操作__proto__,所有叫隐式原型

    什么是原型链
        1.查找对象的属性的时候先从自身找，如果自身没有沿着__proto__找原型对象
        2.如果原型对象上还没有，继续沿着__proto__，直到找到object的原型对象
        3.如果还没有找到，返回undefined
        4.原型链:沿着__proto__查找的这条链就是原型链

    new操作都干了那些事情
        1.创建了一个空对象
        2.将this指向改空对象
        3.执行函数
        4.将执行的结

变量提升 & 函数提升
    1.js引擎在js代码正式执行之前(函数：意为着函数已经被调用)会做一些预解析的工作 
    2.找关键字：var function
    3.找到var以后将var后面的变量提前声明，但是不赋值，等同于var a;
    4.找到function以后提前定义函数体内容,也就是说函数在预解析的时候已经定义完毕
    5.因为预解析提前解析变量和函数：之后根据代码上下顺序开始执行，执行到哪里给那个变量赋值、执行那个代码
    6.注意：
        全局预解析在定义函数的时候不关心函数是否使用
        函数局部预解析的时候如果内部函数没有被使用就不会提前定义

1.变量声明提升
    通过var定义(声明)的变量,在定义语句之前就可以访问到
    值：undefined
2.函数声明提升
    通过function声明的函数,在之前就可以直接调用
    值:函数定义(对象)

注意：
    预解析函数定义优先级高于(var变量)     同名的函数和变量预解析一定是函数的优先级高
    预解析之后不会再看下面的定义的函数了   因为解析的时候函数已经定义 调用的时候直接走预解析

    例子
        var getName = function(){alert(4)};             函数表达式
        function getName(){alert(5)}                    函数定义
    
    预解析之后
        var getName;
        function getName() { alert (5);}
        getName = function () { alert (4);};

    也就是说解析后：函数定义会被函数表达式覆盖(var)


1.代码分类（位置）
    全局代码
    函数代码
2.执行上下文分类
    全局执行上下文          创建全局的变量对象Global
    函数执行上下文          创建函数的变量对象
    eval函数执行上下文

执行上下文
    1.理解：
        执行上下文抽象的概念，代表了执行的环境,包含了：执行环境,变量对象,this,作用域链
    2.流程：
        js引擎在js代码正式执行之前会先创建一个变量对象
        进入该环境以后创建一个变量对象，该对象用于收集该环境下的：变量，函数，函数的参数，this
        找关键字：var function
        确认this的指向
        创建作用域链
    3.重点：
        执行上下文是动态创建的
        尤其是针对函数，每调用一次函数都会创建一次执行上下文,执行完就销毁


执行上下文栈
    1.在全局代码执行前，js引擎就会创建一个栈来储存管理所有的执行上下文
    2.在全局执行上下文(window)确定后，将其添加到栈中(压栈)
    3.在函数执行上下文创建后，将其添加到栈中(压栈)
    4.在当前函数执行完后，将栈顶的对象移除(出栈)
    5.在当前函数执行完后，栈中只剩下下window

预解析重名的时候：先预处理函数，后预处理变量,如果已经存在就会被忽略 

作用域
    1.理解
    它就像一块地盘一样，一个代码片段的所在区域
    它是静态的(相对于执行上下文)，在编写代码的时候就确定了
    2.分类
        全局作用域
        局部作用域
        eval作用域
        块级作用域(ES6就有了)
    3.作用
        隔离变量，不同作用域下同名变量不会有冲突
        规定当前函数之后创建作用域链的上一个链条是什么样的



执行上下文和作用域区别与联系
    区别1
        全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义的时候都已经确定好了，而不是调用的时候
        全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建
        函数执行上下文环境是在调用函数时，函数体代码执行之前创建

    区别2
        作用域时静态的，只要函数定义好了就一直存在，切不会再变化
        上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放
    
    联系
        上下文环境(对象)是从归属于所在的作用域
        全局上下文环境==>全局作用域
        函数上下文环境==>对应的函数使用域

作用域
    作用域分类
        全局
        局部(函数内部)
        块级
    作用域链理解
        抽象的概念概念
        也用来决定代码执行的范围，变量所属的范围
        作用域是代码定义的时候决定的
        作用域的作用：
            隔离变量
            规定当前函数的作用域链是什么样的，体现[[Scopes]]:上一级作用域链
    作用域链
        作用域链是一个数组结构
        该结构内保存的是一个个的变量对象
        作用域链什么时候创建的：在JS代码正式执行之前


作用域链
    1.理解
        多个上下级关系的作用域形成的链式关系，它的方向式从上往下的(从内到外)
        作用域链是一个数组结构的数据，保存着当前作用域的变量对象及其上级作用域的变量对象，直到全局的变量对象
        查找变量的时候就是沿着作用域链来查找的
    2.作用域链式如何产生
        函数在定义的时候自动添加一个属性'[[Scopes]]' 该属性保存的是其上级作用域链
        当函数执行的时候，进入执行上下文环境，将创建的变量对象添加到'[[Scopes]]'数组的第一个位置,形成新的数组
    3.查找一个变量的查找规则
        现在当前作用域的变量对象中查找，如果有就使用
        如果没有就会沿着作用域链的数组上级作用域长的变量对象中查找
        找到就返回对应的值，如果没有就继续向上查找，直到找到最后一个变量对象(全局的变量对象)，如果没有就会报错

闭包 Closure
    1.如何产生闭包(条件)？
        函数嵌套
        内部函数引用外部函数的局部变量
        调用内部函数,注意：函数变量提升的时候,如果内部函数没有被使用,在预解析的时候不会定义/预解析内部函数
    2.闭包到底是什么
        理解一：闭包是嵌套的内部函数                
        理解二：包含被引用变量(函数)的对象          
        理解三: 所谓闭包就是一个引用关系,该引用关系存在于内部函数中,引用的是外部函数的变量对象

    例子：
        function fun1(){
            var a = 123;
            function fun2(){
                console.log(a);
            }
            return fun2
        }
        var f = fun1();
        //正常fun1的变量对象(a、fun2、this)在fun1()调用之后应该销毁，但是因为fun2的引用，
       所以所以变量对象中的a并没有被弹出栈销毁，形成闭包。

闭包的作用
    1.延长外部函数变量对象的生命周期
    2.让函数外部可以操作(读写)到函数内部的数据(变量/函数)
    3.注意：浏览器为了性能后期将函数中不被内部函数使用的变量清除了

闭包的生命周期
    1. 产生：在嵌套内部函数定义执行完时就产生了(不是在调用)
    2. 死亡: 在嵌套的内部函数成为垃圾对象时

闭包的优点和缺点
    优点：延长外部函数变量对象的生命周期
    缺点：延长外部函数变量对象的生命周期(占内存，如果不及时清除容易造成内存溢出,泄漏)

使用闭包的时候注意：
    及时清除闭包
    让内部函数称为垃圾对象 ---> 内部函数身上没有指针指向
    

词法作用域VS动态作用域
    1.作用域分类：
        1.静态作用域(词法作用域) javascript语言
        2.动态作用域：bash等其他语言
    2.特征对比
        1.词法作用域规定作用域在代码定义的时候就决定了,而不是看调用的时候
        2.动态作用域是在代码执行的时候决定

三、对象篇
    1.什么是原型对象    
        多个数据的集合体(封装体)
        用于保存多个数据的容器
    2.为什么要用对象
        方便对于多个数据进行统一管理
    3.对象的组成
        属性：由属性名和属性值组成   属性名都是字符串类型，属性值是任意类型
        方法：是特别的属性==>属性值是函数
    4.访问属性
        obj.属性名      
        obj['属性名']
    5.难点：对象最终保存的属性名一定是一个字符串，如果设置的时候不是字符串,会自动调用toStrong()方法转换为字符串

    在对象中所有的key都是字符串

对象的创建方式
    构造函数模式
            套路：先创建空Object对象，再动态添加属性/方法
            适用场景：起始时不确定对象内部数据
            问题：语句太多

            var obj = new Object();
                obj.name = 'xmt'
                obj.age = 27;    

    对象字面量方式
            套路：使用{}创建对象,同时指定属性/方法
            使用场景：起始时对象内部数据确定
            问题:如果创建多个对象,有重复代码

            var obj1 = { name:"xmt", age:27}
            var obj2 = { name:"yyd", age:27}
            var obj3 = { name:"kkb", age:27}

    工厂模式
            套路：通过工厂函数动态创建对象并且返回
            适用场景：需要创建多个对象
            问题：对象没有一个具体的类型，都是Object类型

            function Person(name, age) {        
                return {                        
                    name: name,
                    age: age
                }
            }
            var p1 = Person('xmt',27)
            var p2 = Person('yyds',50)
            console.log(p2 instanceof Person)           //false 
            因为Person 不是p1、p2的构造函数,他们都是Object创建的,
            一般情况下Person我们叫做类,这个类也可以写成其他的名词，用来分类 

        
    自定义构造函数模式
            套路：自动逸函数,通过new创建对象
            使用场景：需要创建多个类型确定的对象
            问题：每个对象都有相同的数据，浪费内存

            function Person(name, age) {
                this.name = name;
                this.age = age;
            }  
            var p1 = new Person('xmt',27)
            var p2 = new Person('yyds',50)
            console.log(p1)
            console.log(p2)
            console.log(p2 instanceof Person)       //true  

            因为Person 是p1、p2的构造函数,他们都是Person创建的实例化对象,
            一般情况下Person我们叫做类,这个类也可以写成其他的名词（dog），用来分类 
            
    构造函数+原型的组合模式
            套路：自定义构造函数，属性在函数中初始化，方法添加到原型上
            适用场景：需要创建多给类型确定的对象

            function Person(name, age) {
                this.name = name;
                this.age = age;
            }

            Person.prototype.showName = function () {
                console.log(this.name)
            }

继承
    原型链继承
        核心思想： 子类原型 成为 父类的实例
        注意问题： 以上写法会导致子类的构造器属性丢失
        解决方法：
                    Child.prototype = new Parent();
                    Child.prototype.constructor = Child;    
                    
        每个原型对象身上都有一个constructor数据，该属性的目的是为了标识当前的构造器是谁

    方法
        1. 定义父类型构造函数
        2. 给父类型的原型添加方法
        3. 定义子类型的构造函数
        4. 创建父类型的对象赋值给子类型的原型
        5. 将子类型原型的构造属性设置为子类型
        6. 给子类型原型添加方法
        7. 创建子类型的对象: 可以调用父类型的方法


    借用构造函数继承(不是真的继承)
        核心思想：让父类的方法在子类中继承
        注意问题：如果父类的方法在子类中直接调用,会导致在window上添加不必要的属性
        解决方法：
                    使用Call || apply
                    Parent.call(子类的实例对象,参数)
                    Parent.call(this,参数)
        1. 定义父类型构造函数
        2. 定义子类型构造函数
        3. 在子类型构造函数中调用父类型构造

    原型链+借用构造函数的组合继承
            1.利用原型链实现对父类型对象的方法继承
            2.利用call || apply借用父类型构造函数初始化相同属性

        function Parent(name, age) {
                this.name = name;
                this.age = age;
        }

        Child.prototype = new Parent();
        Child.prototype.constructor = Child;

        function Child (name,age,sex){
            Parent.call(this,name,sex)
            this.sex = sex;
        }

        var child = new Child("儿子", 1, '男');

js事件循环(轮询)机制
    1.js都是单线程的 ---> 主线程
    2.同步任务 || 异步任务
        同步：1.阻塞    2.同步是没有回调的
        异步：1.非阻塞  2.异步有回调(用来通知当前异步任务执行的结果)
    3.定时器真的准时么？
        特例：定时器任务的后面有运算量大的代码段
    4.事件轮询机制：
        1.js所有的任务都会在js的主线程执行
        2.当开启一个异步任务的时候会交给对应的管理模块去管理
        3.主线程继续执行后续的任务
        4.管理模块接管对应的回调,它会在恰当的时机将对应的回调放入callback queue中
        5.当主线程上的所有同步任务执行完毕会通过'轮询'的方式询问callback queue是否有可执行的回调
        6.如果没有会反复询问
        7.如果有可执行的回调将对应的回调钩到主线程执行
    5.开发注意事项：
        不要在定时器任务之后放置运算量大的代码段

ES5/6/7严格模式
    1.理解：
        除了正常模式(混杂模式),ES5添加了第二种运行模式,‘严格模式’(strict mode)
    2.目的/作用
        消除代码运行的一些不安全之处，为代码安全运行报价护航
        为未来新版本的javascript做好铺垫
    3.使用
        在全局或者函数的第一条语句定义为：'use strict'
        如果浏览器不支持，只解析为一条简单的语句，没有任何副作用
    4.语法和行为的改变
        必须用var声明变量
        禁止自定义的函数中的this指向window
        创建eval作用域  eval()  自动解析里面的代码 变量在不是严格模式下为全局变量 在严格模式下为局部
        对象不能有重名的属性        

JSON对象
    1.JSON.stringify(obj/arr)
            js对象(数组)转化为json对象(数组)
    2.JSON.parse(json)
            json对象(数组)转化为js对象(数组)

    JSON.stringify()    是将JavaScript 对象转换为 JSON 字符串，
    JSON.parse()        可以将JSON字符串转为一个对象。


ES5 obj扩展了一些静态方法，常用的两个为：
    1.Object.create(prototype,[descriptors])    
        作用：将新的对象以参1对象为指定的原型对象,给新对象添加属性(属性只能以对象的方式添加value:{},value2:{}    )  
        或者理解为，以指定的对象为原型对象，创建一个新的对象
        例子：me = Object.create(person,{        以person为原型对象创建一个新的对象me,并且添加一个属性
            sex:{
                value:指定值
                writable:表示当前属性值是否可以修改，默认false
                configurable:标识当前属性是否可以被删除，默认为false
                enumerable:标识当前属性是否能用for in 枚举，默认fasle
            }
        } );      
        
            

    2.Object.defineProperties(指定的对象,descriptors)   
    2.Object.defineProperty(obj , prop ,descriptors )
        作用：为指定对象定义扩展多个属性

        get:用来获取当前属性值得回调函数
        set:修改当前属性值得触发的回调函数，并且实参为修改后的值
        存储器属性：setter,getter 一个用来监视， 一个用来取值

        
    3. obj.hasOwnProperty('value')  根据Boolean,判断是否是对象自身的属性,而不是原型链的属性

    例子：双向数据绑定obj[a]
        for (var item in obj) {
            if (obj.hasOwnProperty(item)) {
                (function (item) {
                    Object.defineProperties(obj2, {          //通过遍历obj的属性,obj2添加相同的属性
                        [item]: {
                            get: function () {               //设置obj2的属性    
                                return obj[item]          
                            },
                            set: function (msg) {
                                obj[item] = msg             //获取obj2的属性,反向改变obj本体的属性,实现双向改变
                            }
                        }
                    })
                })(item)
            }
        }

Aarray扩展
    Array.prototype.indexOf(value)：得到值在数组中的第一个下标  有的话给下标，没有返回-1
    Array.prototype.lastIndexOf(value)：得到值在数组中的最后一个下标
    Array.prototype.forEach(function(item,index){})：遍历数组
    Array.prototype.map(function(item,index){})：遍历数组返回一个新的数组，返回加工后的值
    Array.prototype.filter(function(item,index){})：遍历过滤除一个新的子数组，返回条件为true的值

例子：
    //加工
    var arr = [0, 1, 2, 3, 4, 5, 6, 7];
    var newArr = arr.map(function (item, index) {
        return  index<3? item + 100: item;      //return 对原数组每一项进行加工,生成新数组
    });

    //过滤生成新数组
        var  newArr2 = arr.filter(function(item,index){
            return item > 3
        });



var 同名变量    
                变量提升:未定义优先级最高、定义数值或者函数的的其次、
                var a = 123;
                var a 
                a
                console.log(a)  123

                

                var a = 10
				function a() {}	
				console.log(a);     //10
ES6:
let关键字
    1.作用：  
        与var类似,用与声明一个变量
    2.变量提升：
        全局变量提升
            会创建一个变量对象(script)用来收集全局作用域下let定义的变量,而不是全局
            因为不是在全局,所以不会是window的属性
        局部变量提升
            会将var let定义的变量全部都放在当前函数的变量对象中
        同var的变量提升的区别
            var提升的变量在未赋值之前可以使用是,值为undefined 
            let提升的变量在未赋值之前不允许被使用,直接报错

    2.特点：
        在块级作用域有效
        不能重复声明变量
        会预处理，有变量提升，但是不能使用提升的变量
    3.应用：
        循环遍历加监听
        使用let取代var是趋势

const关键字
     1.作用：
        定义一个常量
    2.特点：
        不能被修改
        其他特点同let
    3.应用：
        用于不能被修改的数据

    例子：
        const COUNT = 123;          定义一个常量   
        COUNT = 456;                修改会直接报错

变量的解构赋值     (解构、赋值)
     1.理解：
        解析目标对象的解构,赋值给对应的变量
        从对象或者数组中提取数据，并且赋值给变量(多个)
    2.对象的解构赋值
        let{n,a} = {n:xx,a:12}           根据key索取value
    3.数组的解构赋值
        let[a,b] = [1, 2]                根据index索取value
    4.用途
        给多个形参赋值
        解构函数的参数对象
        //let 形参 = 实参;
        //let {username,age} = {username: 'xmt', age: 43};


        let obj2 = {username: 'xmt', age: 43,sex:'男'};
        function fun2({username,age}) {         
            console.log(username)
            console.log(age)
        }
        fun2(obj2)
    
模板字符串：简化字符串的拼接
        模板字符串必须用 ``包裹  （英文书写,位置在1数字前面的按键） 
        变化的部分使用${xxx}定义

    str = '我的名字是：' + obj.username + ',我的年龄是：' + obj.age;

    str =  `我的名字是：${obj.username},我的年龄是：${obj.age}` 

简化的对象写法  对象简写

        省略同名的属性值
        省略方法的function
        例如简写对象：
            let x = 2;
            let y = 3;
            let point = {
                x,                       //同名的属性和值可以省略 key和value一样的时候
                y,
                set (x) { this, x = y}   //省略:funmction
            }
    
    例子：
        let username = 'xmt';
        let age = 43;

        简写                                        常规写法
        let obj2 = {                                let obj = {
            username,                                    username:username,
            age,                                         age:age,
            showName(){                                  showName:function(){
                console.log(this.username);                 console.log(this.username);
            }                                           }
        }                                           }

箭头函数
    作用：定义匿名函数
    基本语法：
    没有参数： ()=> console.log(xxx)
    一个参数： i => i+2
    多个参数： (i,j) => i+j
    函数体不用大括号：默认返回结果
    函数体如果有多个语句,需要用{}包围,若有需要返回的内容,需要手动返回
    使用场景：多用来定义回调函数

    箭头函数的特点：
    简洁
    this:
    箭头函数没有自己的this,箭头函数的this不是调用的时候决定的,而是在定义的时候处在的上下文对象就是它的this
    箭头函数的this看外层是否有函数,如果有,外层函数的this就是箭头函数的this，如果没有,this就是window
    箭头函数不能用作构造函数

箭头函数左边参数：
    箭头函数 没有形参的时候,()不能省略，用来占位
        let fun3 = () => console.log('没有形参的时候');

    箭头函数 有一个形参的时候,()可写、可不写
        let fun4 = a => console.log('只有一个形参的时候', a);

    箭头函数 有多个形参的时候,()不能省略,
        let fun5 = (a, b) => console.log('有多个形参的时候', a, b);

箭头函数右边函数体：
    箭头函数的函数体只有一条语句的时候{}可以省略,当{}省略的时候会自动returen当前语句/表达式
        let fun6 = () => console.log('函数体只有一条语句的时候');   //return cosole.log()函数返回的undefined
        let fun7 = () => 123;       //return 123

    箭头函数的函数体有多条语句的时候，{}不能省略,当{}不能省略的时候会需要手动返回结果
    否则默认执行 return value undefined; 
        let fun8 = () => {
                let a = 1;
                console.log('函数有多条语句的时候');
                return a;
            }  

点点点运算符 三点运算符
 1.rest(可变)参数
    用来取代arguments,但是比arguments灵活,只能是最后部分形参的参数
    也就是实参比形参数量多， 形参接收不完的才会放进 ...varlues里面

    arguments 用来收集实参的伪数组
    伪数组(它的原型对象是Object的原型对象,而不是Array的原型对象)
    伪数组有length属性,可以通过下标获取对应的值,但是没有数组的一般方法(push,filter,map)

    //用途1 函数中
    function fun(a,b,...values){
        console.log(arguments);     //1,2,3,4组成为数组     传入的实参，不能使用数组的方法
        console.log(values);        //3,4组成真数组         传入比形参多的实参、并且可以使用数组的方法
    }
    fun(1,2,3,4)

    //用途2 函数中
    function fun (...values) {}             //代表所有接收的实参都会在调用values的时候形成真数组

    //用途3 数组中扩展运算符           
    let arr = [1,6];
    let arr2 = [2,3,4,5];
    let arr3 = [1,...arr2,6]                //  ...运算符去拆包 相当于直接把arr2数组的元素直接拆解
    console.log(arr3)                       // [1,2,3,4,5,6]
    

形参默认值：当不传入参数的时候默认使用形参的默认值

    function Point3(x = 1, y = 2) {
            this.x = x;
            this.y = y;
        }

    let point3 = new Point3();      如果不传参调用的时候也会有默认的形参值

    应用场景：
    //不写arr=[]样式话就是 形参值是Undefined报错,在这里设置形参默认值是一个空数组,如果没参数就按空数组处理
    function fun(arr=[]){                       
            arr.forEach(function(item,index){
                console.log(index,item);
            });
        }

    let arr = [1,2,3];
    fun(arr);
    fun();
    
Symbol
    ES5中对象的属性都是字符串,容易造成重名，污染环境
    symbol：
        概念：ES6添加的一种原始数据类型symbol(已有的原始数据类型:String,Number,Boolean,undefined, Null,
        Array,Object,)
        特点：
            1.symbol属性对应的值是唯一的，解决命名冲突问题
            2.symbol值不能与其他数据进行计算,包括字符串拼接
            3.for in, for of遍历时都不会遍历symbol属性
        使用：
            1.调用symbol函数得到symbol值
                let symbol = symbol();
                let obj = {};
                obj[symbol] = 'hello'
            2.传参标识
                let symbol == symbol('one');
                let symbo2 == symbol('two');
            3.内置symbol值
                除了定义自己使用symbol值以外,ES6还提供了11个内置symbol值，指向语言内部使用过的方法
                对象的symbol.iterator属性,指向该对象的默认遍历器方法

iterator遍历器(迭代器) 
    概念: iterator是一种接口机制，位各个不同的数据解构提供统一的访问机制
    作用：
        1.为各种数据解构，提供一个统一的、方便的访问接口
        2.使得数据解构的从成员能够按某种次序排列
        3.ES6创造了一种新的遍历命令for...of循环，inerator接口主要提供for...for
    工作原理：
        创建一个指针对象(遍历器对象),指向数据解构的起始位置
        第一次调用next方法，指针自动指向数据解构的第一个恒源
        接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员
        每调用next方法返回的是一个包含value和done的对象(value：当前成员的值，done:布尔值)
        value标识当前成员的值,done对应的布尔值表示当前的数据的解构是否遍历结束
        当遍历接收的时候返回value的值是undefined，done的值为false
    原生具备iterator接口的数据(可用for...of遍历)
        1.Array
        2.arguments
        3.set容器
        4.map容器
        5.String

class类
    1.通过class定义类/实现类的继承
    2.在类中通过constructor定义构造方法
    3.通过new来创建类的实例
    4.通过extends来实现类的继承
    5.通过super调用父类的构造方法
    6.重写从父类中继承的一般方法

        class Promise1 {
            static num = 123;               //使用static可以给类/对象自身添加私有属性 static静态资源修饰符
            constructor(name, age) {        //类的构造函数 实例里面的内容写在这里
                this.name = name;
                this.age = age;
            }

            showInfo() {                    //类的一般方法，在原型对象里面的方法或者属性
                console.log(this.name, this.age);
            }
        }

        let p1 = new Promise1('xmt', 18)        //创建实例
        console.log(p1);                        
        p1.showInfo()                           //调用方法，方法在类的原型对象上，实例没有就往原型对象上找
        console.log(Promise1.num);              //父类的私有属性

        class Child extends Promise1 {          //子类继承父类的属性和方法
            constructor(name, gae, sex) {       //当父类的的构造函数内容不够用时，可以根据需求重写或者修改
                super(name, gae);               //super做的事情:1.调用父类的方法 2.改造父类构造方法的this指向子类的实例
                this.sex = sex;
            }
            showInfo() {                        //当父类原型对象的方法不能满足子类的需求的时候重写方法
              console.log(this.name +'的年龄是'+ this.age + this.sex);
            } 
        }

        let p2 =  new Child('xmmm',200,'男') 
        console.log(p2);
        p2.showInfo()                               //修改重写后的类原型对象的方法
        console.log(Child.num);                     //继承了父类的私有属性

ES6 Set和Map

    Set容器：无序的不可重复的多个value的集合体
        set = new Set(array)
        add(value)      添加
        has(value)      判断是否有
        delete(value)   删除某一项,一次只能删除一个
        clear()         全部清空
        size            类似length

    Map容器： 无序的key不重复的多个key-value的集合体
        map = new Map()     [ [1,'xmt'] , [2,'age'] ] 只能是这种样式的二维数组
        Map(array)
        set(key,value)
        get(key)
        delete(key)
        has(key)
        clear()
        size

for...of循环
    for(let value of target){}循环遍历可以遍历
        1. 遍历数组
        2. 遍历Set
        3. 遍历Map
        4. 遍历字符串
        5. 遍历伪数组


数组去重
    ES5的方法
    let arr = [1, 2, 3, 1, 2, 3, 1, 2, 3];
    for(let item of arr){
        let result = [ ];
        if(result.indexOf(item) == -1 ){
            result.push(item)
        }
    };


    arr.forEach(function(item){
        if(result.indexOf(item) == -1 ){
            let result = [ ];
            result.push(item)
        }
    } );

    ES6的方法
    1.  let uniqueArr  (arr) =>  [...new Set(arr)];
    2.  let set = new Set(arr);
        let newArr = Array.from(set); 


for...in    对遍历象, 遍历数组                                      循环的是键
for...of    对遍历象, 遍历数组、伪数组、字符串、Set\Map容器           循环的是值
Array.prototype.forEach (function(item, index){} )                 遍历数组

Object.values()获取对象value的集合
Object.keys()获取对象key的集合

    一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环。
    obj对象没有Symbol.iterator属性 所以会报错。
    如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象key的集合后,再使用 for of

    let obj = {a: '1', b: '2', c: '3', d: '4'}
        for (let key of Object.keys(obj)) {
        console.log(o) // 1,2,3,4
    }   



    一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环。例子中的obj对象没有

拷贝前言
let obj = {username :'123'};
let obj2 = obj;             //obj保存的地址给了obj2,引用传递    只有引用数据类型才是拷贝

let num = 123;
let num2 = num ;        //值传递,修改新的数据不会影响原数据  基本数据类型只是赋值,不是拷贝


克隆数据:   对象/数组
        1.区别：浅拷贝/深度拷贝
            判断：拷贝是否产生了新的数组,还是拷贝的是数据的引用地址
            知识点：对象数据存放的是对象在栈内存的引用地址,直接复制的是对象的引用
            let obb1 = {age:18}
            let obj2 = obj1         复制了obj在栈内存的引用

        2.常用的拷贝技术
            arr.concat()       数组浅拷贝
            arr.slice()        数组浅拷贝
            JSON.parse(JSON.stringify(arr/obj))    数组/对象深拷贝,但是不能处理函数数据
            浅拷贝包含函数数据的对象/数组
            深拷贝包含函数数据的对象/数组


        拷贝的本质：
            let obj11 = {username :123};
            let obj22 = {};
            obj22.username = obj11.username;
            obj22.username = 456;
            console.log(obj11.username,obj22.username)

            判断深拷贝还是浅拷贝:看修改拷贝后的数据会不会影响原数据,如果影响浅拷贝,不影响深拷贝

    浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
    但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
    
    当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。
    也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。
    浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。
    如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，
    因此如果其中一个对象改变了这个地址，就会影响到另一个对象。
    即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。   



总结问题:
    给对象属性赋值的优先级高于给对象赋值        a.x = a = {10}
    同名的变量和函数预解析，变量优先级高也就是先预解析变量,但打印预解析必是函数,因为函数预解析在后,
    预解析之后：函数除了调用不会再看再执行函数内代码，所以调用函数前要看变量赋值没有，如果赋值了会报错
    
    var a = 10
    function a (){
        console.log(20)
    }
    a()     //会报错
