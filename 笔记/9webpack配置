webpack快速入门教程
    什么是webpack
        Webpack是一个模块打包器(bundler)。
        在Webpack看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理
        它将根据模块的依赖关系进行静态分析，生成对应的静态资源
    五个核心概念
        Entry：入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。
        Output：output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。
        Loader：loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只能解析 JavaScript）。
        Plugins：插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。
        Mode：模式，有生产模式production和开发模式development
    理解Loader
        Webpack 本身只能加载JS/JSON模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载
        Loader 本身也是运行在 node.js 环境中的 JavaScript 模块
        它本身是一个函数，接受源文件作为参数，返回转换的结果
        loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。
    理解Plugins
        插件可以完成一些loader不能完成的功能。
        插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。
    配置文件(默认)
        webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象

1.webpack的核心概念
	Entry：入口，Webpack进行打包的起始点(文件)
	Output：输出，webpack编译打包生成的bundle(打包文件)
	Loader：模块加载(转换)器，将非js、非json模块包装成webpack能理解的js模块
	Plugin：插件，在 Webpack 构建流程中的特定时机插入具有特定功能的代码
	Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件, 如果是其它类型文件利用对应的loader转换为js模块
	Model:工作模式，可选：开发模式、生产模式

2.webpack配置文件的整体结构
	module.exports = {	
	  entry: '', //入口
	  output: {},//输出
	  model:工作模式
	  module: {rules: []},//配置loader
	  plugins: [], //配置plugin
	}

3.webpack模块化打包的基本流程
	1. 连接: webpack从入口JS开始, 递归查找出所有相关联的模块, 并【连接】起来形成一个图(网)的结构
	2. 编译: 将JS模块中的模块化语法【编译】为浏览器可以直接运行的模块语法(当然其它类型资源也会处理)
	3. 合并: 将图中所有编译过的模块【合并】成一个或少量的几个bundle文件, 浏览器真正运行是打包生成的bundle文件

4.比较loader与plugin
	1). loader: 用于加载特定类型的资源文件, webpack本身只能打包js。
	2). plugin: 用来扩展webpack其它方面的功能, 一般loader处理不了的资源、完成不了的操作交给插件处理。

5.区别live-reload（自动刷新）与hot-realod/HMR（热模替换）
	相同点: 
		代码修改后都会自动重新编译打包
	不同点: 
		live-reload: 刷新整体页面, 从而查看到最新代码的效果, 页面状态全部都是新的。
		Hot-reload: 没有刷新整个页面, 只是加载了修改模块的打包文件并运行,
		从而更新页面的局部界面, 整个界面的其它部分的状态还在

6.webpack常用loader与plugin汇总
	loader:
		1.【less-loader】:用于将less文件翻译成为css
		2.【css-loader】：用于将css以CommonJs语法打包到js中
		3.【style-loader】：用于动态创建一个style标签，将css引入页面
				备注：上述三个loader一般配合使用，最终实现：翻译less为css，以style标签形式将样式引入页面。
		
		4.【file-loader】：提取源代码图片资源，到指定位置，可修改文件名等操作。
		5.【url-loader】：与file-loader功能几乎一致，优势是可以对图片进行动态转换base64编码（控制limit属性值可以控制阈值）。
				备注：上述两个loader中url-loader应用比file-loader广泛。
		6.【esint-loader】：对项目中的js语法进行检查。
				
		7.【babel-loader】：将es6语法转换为es5语法
				备注1：直接使用只能处理简单的语法，Promise等无法处理。
				备注2：借助polyfill完成高级es6语法的转换，缺点：所有都转换，无法按需转换，生成的js体积大。
				备注3：使用core-js配合polyfill完成按需转换。
				
		8.【postcss-loader配合auto-prefixer】：用于扩展css前缀
				备注：
					(1).该loader需要一个.browserslistrc配置文件。
					(2).该loader要配合autoprefixer库使用。
					(3).使用的时机为：["css-loader","扩展前缀","less-loader"]
			

	pulgin：
		1.【extract-text-webpack-plugin】：用于提取项目中的css,最终合并为一个单独的文件。
				备注：上述插件需要配合：css-loader、less-loader两个loader使用，css-loader、less-loader处理之后，交给extract-text-webpack-plugin处理。
		2.【html-webpack-plugin】：自动创建html文件，且自动引入外部资源。配置项如下：
				 title:"webpack",
			     filename:"index.html",
			     template:"./src/index.html"
			     //用于压缩html
			      minify:{
                         removeComments:true, //移除注释
                         collapseWhitespace:true}//移除换行
		3.【clean-webpack-plugin】：清空webpack的输出目录，防止其他文件“乱入”。
		4.【MiniCssExtractPlugin 】：用于提取css为单独文件
		5.OptimizeCssAssetsPlugin,用于压缩css	
				
  


一、(基础知识了解) (基础知识了解) (基础知识了解) (基础知识了解) (基础知识了解) (基础知识了解) (基础知识了解) (基础知识了解)
    生成package.json依赖声明文件:用来管理node项目的node_modules文件   

    怎么生成package.json？    npm init
      
    怎么用别人的package.json?
        删除了module文件夹  拿到包直接npm install
        只安装package.json里的dependencies（运行依赖）文件      npm install --dependencies 
        只安装package.json里的devDependencies（开发依赖）文件   npm install --devDependencies

    常见的webpack中命令
            npm install webpack webpack-cli -g     全局安装,作为指令使用
            npm remove webpack webpack-cli -g      卸载全局安装webpack
            npm install webpack webpack-cli -D     本地安装,作为本地依赖使用
            npm install xxx@4.3.0                  安装指定版本的包
            webpack                                是调用全局安装webpack的命令/不推荐使用，因为所有的项目都是一个weboack配置
            npx webpack --mode development         指定使用开发模式
            npx webpack                            npx是npm内置的一个包,会自动查找当前依赖包中的可执行文件,
            在局部安装webpack的时候使用,里面有一个默认的配置找src文件夹下的index.js文件进行打包,默认只用的是生成模式
------------------------------------------------------------------------------------------------------------------------  

二、(项目开始需要两个文件:package.json/webpack.config.js ) (项目开始需要两个文件:package.json/webpack.config.js ) (项目开始需要两个文件:package.json/webpack.config.js ) (项目开始需要两个文件:package.json/webpack.config.js ) 
    1.配置package.json用来记录安装下载包      直接手写,或者npm init  或者yarn init -y

    2.安装webpack及插件(-D 局部安装)
        yarn init -y                            初始化
        创建入口js: src/index.js                 创建src文件夹下的inxex.js
        yarn add -D webpack webpack-cli         安装webpack 和 webpack指令包
        yarn add -D html-webpack-plugin@3.2.0   用来Html文件自动引入:打包后的src文件夹下的index.js文件
        yarn add -D webpack-dev-server@3.9.0    生成一个开发服务器,修改代码时自动在内存中打包且渲染刷新页面
        yarn add -D babel-loader @babel/core @babel/preset-env  (@8.0.6 / @7.7.7 / @7.7.7 )   把ES6转换为ES5 例如箭头函数转为普通函数
                    bable本身不编译ES6的语法
                    bable需要基于它的plugin了做ES语法的编译
                    每个语法都有一个对应的bable plugin来编译对应的语法
                    一个bable preset包是包含多个常用的bable plugin的预设集合包
                    便于管理配置
        yarn add -D css-loader style-loader     从右执行loader先把css代码捞到js，再把js里面的css捞到页面中去
        yarn add -D url-loader@2.3.0 file-loader@4.3.0  处理图片的路径引入及打包

    3.创建webpack.config.js文件             
        用的是commonjs模块化语法向外暴露一个配置对象：用来设置webpack配置,例如配置html-webpack-plugin插件打包
        哪个文件夹下？的哪个js文件? 输出到哪个文件夹下？名字叫什么

    4.打包js文件和html文件
        依据上面配置把根目录的index.html和src文件夹下的inxex.js文件夹打包到dist文件夹，且自动引入js
        npx webpack                             使用npm内置的包npx,调用局部webpack
                                                依据webpack.config.js文件的配置进行文件的打包,(默认生成模式)。 
        npx webpack --mode development          开发模式配置打包

    
        在package.json文件的scripts写配置命令简写后：
            "scripts": {"
                "build":"webpack --mode production"            
                "dev":"webpack-dev-server --mode development"    
            },   

        直接调用yarn build可以省略npx webpack写法的命令,调用局部webpack，生产模式直接实现打包
        直接调用yarn dev可以省略启动服务器的命令,开发模式实现启动服务器:直接在内存中打包文件(硬盘中
        没有保存),且根据代码的修改实时的进行代码的打包,页面的刷新渲染
------------------------------------------------------------------------------------------------------------------------

三、(package.json文件配置详情:应该是输入命令npm init,且安装包之后自动生成的 ,也可以复制之后直接npm install )  
--------------------------------------------------------------------------------------------------------------------------------  
    {
        "name": "webpack_test",
        "version": "1.0.0",
        "scripts": {                    配置命令简写
            "build":"webpack --mode production"            
            "dev":"webpack-dev-server --mode development"    
        },
        "dependencies":{},              生产依赖声明    用来执行项目运行的                
        "devDependencies":{             开发依赖声明    用来webpack编译打包项目的,运行的时候不需要        
            "webpack": "^4.41.5",       
            "webpack-cli": "^3.3.10"    
            "@babel/core": "^7.14.8",
            "@babel/preset-env": "^7.14.8",
            "babel-loader": "^8.2.2",
            "clean-webpack-plugin": "^4.0.0-alpha.0",
            "css-loader": "3.2.1",
            "file-loader": "4.3.0",
            "html-webpack-plugin": "3.2.0",
            "style-loader": "1.0.1",
            "url-loader": "2.3.0",
            "vue-loader": "15.8.3",
            "vue-template-compiler": "2.6.11",
            "webpack": "^4.41.5",       安装webpack包，用来打包文件
            "webpack-cli": "^3.3.10",   用来执行webpack命令
            "webpack-dev-server": "3.9.0"
        }            
    } 

四、(webpack.config.js文件配置详情：) (webpack.config.js文件配置详情：) (webpack.config.js文件配置详情：) (webpack.config.js文件配置详情：)
-------------------------------------------------------------------------------------------------------------      


    配置一个基础的打包环境，用的是commonjs模块化语法 向外暴露一个配置对象 

    //path是node内置的一个包,不需要下载,里面有一个全局变量：__dirname  (当前文件所在目录的绝对路径)
    //它是一个对象，里面有一个函数,可以用来拼接绝对路径path.resolve(__dirname, 'xxx')  config文件所在的跟目录下+xxx文件夹
    const path = require('path')
    function resolve(dir) {
        return path.resolve(__dirname, dir)
    }

    const HtmlWebpackPlugin = require('html-webpack-plugin') //构造函数:打包生成新的index.html文件且自动引入打包后的js
    const { CleanWebpackPlugin } = require('clean-webpack-plugin');//清除打包文件夹dist
    const VueLoaderPlugin = require('vue-loader/lib/plugin')


    module.exports = {
        //模式:这里可以不写,在package.json文件的"scripts":{key：webpack --mode production}简化命令中配置模式
        // mode:'development',         //开发者模式

        //入口
        // entry:'./src/index.js',
        entry: {
            app: './src/index.js'
        },

        //出口：指定打包后的文件输出路径
        output: {
            //path.resolve()用来拼接绝对路径
            path: resolve('dist'),    //所有打包生成文件的基础路径： 现在的path值是dist文件夹下的绝对路径
            //打包后的js文件名字：[name].是占位符,写了=入口文件属性名app,最终输出文件名为app.bundle.js
            filename: '[name].bundle.js'

        },

        //模块打包器/加载器
        module: {
            rules: [ //内部配置loader
                {   //处理ES6转换ES5
                    test: /\.js$/,          //处理js文件
                    // exclude: /(node_modules|bower_components)/, //排除匹配哪些文件夹
                    include: [resolve('src')],                     //只对哪个文件夹处理
                    use: {
                        loader: 'babel-loader',                    //打包处理 ES6/CSS/图片
                        options: {
                            presets: ['@babel/preset-env'],        //配置预设包(包含多个ES语法解析的包)
                            plugins: [                             //预设包之外的插件包

                            ]
                        }
                    }
                },
                {   //处理CSS
                    test: /\.css$/,
                    //先把css代码捞到js，再把js里面的css捞到页面中去,多个loader从右到左处理,从下往上处理
                    //下载vue-loader和vue-template-compiler后把style-loader前面加上vue,对原本插件进行增强补充,不用再下载vue-style-loader,它是内置的
                    use: ['vue-style-loader', 'css-loader'],

                },
                {   //处理图片
                    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
                    // loader: 'file-loader',   //不会进行小图片的base64处理
                    //url-loader内部会使用file-loader，但是不会自动下载需要手动下载
                    loader: 'url-loader',      //会进行小图片的base64处理 (把小的图片转为数字代码的形式)
                    options: {
                        limit: 10 * 1024,       //设置临界值：小于10k的图片就进行base64处理
                        name: 'static/img/[name].[hash:7].[ext]' // 相对于output.path设置路径和名字
                        //[name]占位符 源文件是什么名字 打包后还是什么名字
                        //.[hash:7]设置哈希值：log.716f3b9.jpg  (716f3b9)就是哈希值
                        //.[ext]占位符 源文件是什么扩展名 打包后还是什么扩展名

                    }
                },
                {   //vue相关的
                    test: /\.vue$/,
                    loader: 'vue-loader'
                }


            ]
        },

        //插件
        plugins: [   //插件相当于是构造函数，这里放的都是插件的实例对象
            new HtmlWebpackPlugin({     //在执行命令文件所在目录下查找index.html,打包html后自动引入打包后的js
                template: 'index.html'
            }),
            new CleanWebpackPlugin(),   //每次打包,先清空输出文件夹
            new VueLoaderPlugin(),      //vue相关的插件

        ],

        //配置开发服务器,实时刷新页面：安装webpack-dev-server
        devServer: {
            port: 8081,
            open: true, // 自动打开浏览器
            quiet: true, // 不做太多日志输出
            
        },

        //模块引入解析配置： 忽略后缀、简化路径使用路径别名
        resolve: {
            //好处：简化模块路径的编写、加快打包
            alias: {                                    //模块路径别名(简写方式)    先找别名、找不到去node_modules找
                '@': resolve('src'),                    //相当于@就直接定位到src的绝对路径
                '@com': resolve('src/components'),      
                // 'vue$': 'vue/dist/vue.esm.js',       // 表示精准匹配：引入以vue结尾的直接找vue/dist/vue.esm.js,引入带编译器版本的vue
            },
            extensions: ['.js', '.vue', '.json'],       // 可以省略的后缀名
        },

        //开启sourec-map 浏览器就支持这个功能，不用下载安装包：出错可以映射到源文件，而不是打包后的文件
        devtool:'cheap-module-eval-source-map'
    }
            
          
 -------------------------------------------------------------------------------------------------------------

              
五、记住几个点：记住几个点：记住几个点：记住几个点：记住几个点：记住几个点：记住几个点：记住几个点：记住几个点：记住几个点：记住几个点：记住几个点：
    1.webpack的resolve配置能够做些什么
        extensions：指定可以省略的模块文件后缀： .js  .css  .vue等待
        alias:      引入路径别名：用法类似与变量接收一个路径地址 使用的时候简化代码 / 加快打包

    2.如何配置vue单文件组件开发的环境,在基础webpack的配置上添加vue配置
        下载包:
            yarn add vue                             安装vue相关的组件
            yarn add -D vue-loader@15.8.3
            yarn add -D vue-template-compiler@2.6.11 安装vue模板打包编译器,是在打包前进行编译,这个不会带包时带进打包文件,   

        配置:
            vue-loader
            VueLoaderPlugin
            vue-style-loader          安装上面下载包之后,内置这个配置,不用额外下载这个包
    
    3.自定义vue开发环境有没有遇见什么问题？例如在使用Vue组件化文件中使用:
        
        <template>   
            <Header>                        使用注册过的组件模板的时候报错
        </template>  

        <script>
            export default {
                data(){},                   自身可变数据    --vue模板中需要显示的数据来源有哪3个
                props: []/{}                外部(父组件)传入--vue模板中需要显示的数据来源有哪3个
                computed: {}                计算属性产生的  --vue模板中需要显示的数据来源有哪3个
                methods: {},                回调函数-更新数据
                watch: {}                   深度监视-监视数据-监视引用数据类型
                filters: {}                 自定义过滤器
                directives: {}              自定义Vue.directive全局注册指令  directive:{}局部注册指令
                components: {Header}        局部注册组件
        </script>

        <style scoped>
        </style>
                
        问题：都不会被识别,运行报错，提示当前vue版本只是一个运行时版本，不带模板编译器

        原因：
            template的编译需要使用vue的编译模板的代码
            它没有使用vue-template-compiler包

        解决:
            办法1：
                配置webpack指定使用vue带编译器的版本的文件,resolve：{alias:{vue$': 'vue/dist/vue.esm.js',}}
                表示精准匹配：引入以vue结尾的直接找vue/dist/vue.esm.js,引入带编译器版本的vue

            办法2：
                index.js汇总文件使用render: h => h(),原理内部使用vue-template-compiler包进行预编译vue组件模板

        那种方法最好：
            方法1：是使用vue自带的编译包，打包的时候文件大
            方法2：用vue-template-compiler解析，打包的是写编译后文件，文件更小


		办法1:去webpack配置:
		resolve:{
			alias:{ 	
				'vue$': 'vue/dist/vue.esm.js',  	//表示精准匹配:去找node_modules下vue/dist/vue.esm.js文件 
			},
		}

		方法2:引入vue汇总文件的时候使用render内部使用vue-template-compiler包进行预编译vue组件模板
			import App from './App'					
			new Vue({
    			el: '#root',
    			render: h => h(App)  
			})

    4. 列出vue常用的配置选项
        el
		data
		props			
		computed		计算属性
		watch			深度监视-监视数据
		methods			回调函数-更新数据
		filters			自定义过滤器
		directives		自定义Vue.directive全局注册指令  directive:{}局部注册指令
		components		局部注册组件

    5.组件化开发的基本流程和2个重要的问题:

		拆分组件:   拆分界面，定义组件
		静态组件:   使用组件搭建静态页面
		动态组件：  初始化动态显示
		交互：      与用户/后台	
			
		2个重要问题:
			数据定义在那个组件？    
			更新数据的方法定义在那个组件？数据在哪个组件，方法就定义在哪个组件
		3个设计数据的问题
			类型
			名称
			在那个组件

    6.模板中需要显示的数据来源有哪3个
        data            自身可变数据
        props           外部(父组件)传入的数据
        computed        依据已有的data/props/其他computed进行计算产生的可变数据
-------------------------------------------------------------------------------------------------------------------------
         
        
   

        













		